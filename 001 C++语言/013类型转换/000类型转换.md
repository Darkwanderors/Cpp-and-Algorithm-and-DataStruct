# C语言中的类型转换

在C语言中，如果赋值运算符左右两侧类型不同，或者形参与实参类型不匹配，或者返回值类型与接收返回值类型不一致时，就需要发生类型转化。

C语言中总共有两种形式的类型转换：**隐式类型转换**和**显式类型转换**。

1. 隐式类型转化：编译器在编译阶段自动进行，能转就转，不能转就编译失败。

2. 显式类型转化：需要用户自己处理。语法上称呼显式转化为强制转化（简称强转）。

只有相近类型才能进行隐式转换，意义相近指能比较数据大小。比如`int`和`double`。

而指针表示数据在计算机中的物理地址，和`int`不能隐式转换，但互相强转是可以的。

但这种转换的可视性比较差，所有的转换形式都是以一种相同形式书写，难以跟踪错误的转换。因此C++提出了自己的类型转化风格，因为C++要兼容C语言，所以C++中还可以使用C语言的转化风格。

# static_cast

对应c语言的隐式类型转换。

`static_cast`用于**非多态类型的转换**（静态转换），编译器隐式执行的任何类型转换都可用`static_cast`，但它**不能用于两个不相关的类型进行转换**。

相近类型（指意义相似的类型）用这个。

c++新增的类型转换在使用上很像类模板的匿名对象，但`<>`内不能上传仿函数和仿函数的指针。

简单使用`static_cast`：

```cpp
#include<iostream>
using namespace std;

void f1() {
	int a = 3;
	int b = 3.1;//支持隐式类型转换
	cout << a << endl;
	cout << b << endl;
	double c = static_cast<double>(a);
	printf("%lf\n",c);
}

void f2() {
	class A {};
	class B :public A {};
	B a;
	A* p1 = static_cast<A*>(&a);//允许子类指针强转为父类
	A& p2 = static_cast<A&>(a);

	A aa;
	B* p3 = static_cast<B*>(&aa);//虽然不限制但不推荐父类指针强转为子类
	B& p4 = static_cast<B&>(aa);//因为父类指针可能指向父类对象
}

void f3() {
	int x = 10;
	void* vp = &x;
	int* p = static_cast<int*>(vp);  // 恢复原始类型
}

void f4() {
	class MyInt {
	public:

		//不加explicit，可能会导致形如 MyInt mi = 42; 的情况发生
		explicit MyInt(int x) : val(x) {}

		//重载强制转换操作符
		operator int() const {
			return val;
		}
	private:
		int val;
	};
	MyInt mi = static_cast<MyInt>(42);// 显式调用构造函数
	int n = static_cast<int>(mi);// 显式调用转换函数
}

int main() {
	//f1();//内置类型
	//f2();//有继承关系的父子类指针
	//f3();//显式恢复void*指针的原始类型
	f4();//显式调用构造函数、转换函数
	return 0;
}
```





# reinterpret_cast

有一定关联但意义不相似的类型转换用这个。

`reinterpret_cast`操作符通常**为操作数的位模式提供较低层次的重新解释**，用于将一种类型转换为另一种不同的类型。位模式转换是指：在不改变底层二进制数据的前提下，强制编译器以新类型的方式解释同一段内存。

`reinterpret_cast`是 C++ 中最强大但也最危险的类型转换运算符，因为它主要用于毫不相关的类型之间的强制转换，而且无任何安全性检查、无额外开销，主打一个“信任程序员”。当其他转换运算符无法满足需求时，`reinterpret_cast`一般作为最后的选择。

因此`reinterpret_cast`几乎就是c风格强制转换换了个皮套。

```cpp
#include<iostream>
using namespace std;

void f1() {
	double x = 3.0;
	//int a = reinterpret_cast<int>(x);//int和double是相关类型，不可转换
	int* a = reinterpret_cast<int*>(&x);//2个不相关的指针
	double* b = reinterpret_cast<double*>(a);
	cout << (void*)(&x) << endl;
	cout << (void*)(a) << endl;
	cout << (void*)(b) << endl;
}

void f2() {
	void* p = malloc(100);
	unsigned int i = reinterpret_cast<unsigned int>(p); // 指针转整数
	void* p2 = reinterpret_cast<void*>(i); // 整数转指针
	cout << hex<<i << endl;
	cout << (void*)(p2) << endl;
}

void f3() {
	using p1 = void(*)();
	using p2 = int(*)(int);

	p1 func = []() {};
	p2 anotherFunc = reinterpret_cast<p2>(func);
}

void f4() {
	class A {
	public:
		int x;
		int y;
	};
	//指向类成员的指针A::*存储的是成员在类中的偏移量信息
	//不是实际内存地址
	int A::* p = &A::y;
	void* vp = reinterpret_cast<void*&>(p);//将成员指针的引用强行解释为void*型
	cout << vp << endl;//按照对齐规则，输出4
}

//void f5() {
//	int i = 42;
//	// 不保证在所有平台上都有意义
//	float f = reinterpret_cast<float&>(i);
//}

int main() {
	//f1();//2个不相关的指针之间的转换
	//f2();//指针和整数之间的转换
	//f3();//函数指针之间的转换
	f4();//违反严格别名规则的访问
	//f5();//不保证可移植性的类型转换，不适用reinterpret_cast转换，建议直接逐bit拷贝，或强制类型转换
	return 0;
}
```



# const_cast

`const_cast`最常用的用途就是删除变量的`const`属性，方便赋值。

`const`的使用场景：

```cpp
#include<iostream>
using namespace std;

void _f1(const int& x) {
	int& y = const_cast<int&>(x);//移除const属性
	y = 42; 
}

void f1() {
	int x = 10;
	cout << x << endl;
	_f1(x);
	cout << x << endl;
}

void _f2(char* str) {
	cout << str << endl;
}

void f2() {
	const char* str = "abc";
	_f2(const_cast<char*>(str));//移除const属性，提升权限
}

void f3() {
	class Cache {
	public:
		////mutable关键字用于修饰类的成员变量，它的主要作用是：
		////允许在 const 成员函数中修改被声明为 mutable 的成员变量。
		//mutable int cached_value=0;
		int cached_value = 0;
		int getValue() const {
			if (cached_value == 0) {
				//cached_value = 6;
				////删除this指针的const属性使成员可以修改
				const_cast<Cache*>(this)->cached_value = //compute()
					6; // 安全，因为mutable
			}
			return cached_value;
		}
	};
	Cache x;
	x.getValue();
	cout<<x.cached_value << endl;
}

void f4() {
	int x = 10;
	////强制转换成带const属性的int引用
	//const_cast<const int&>(x) = 3;
}

int main() {
	//f1();//移除 const 限定符
	//f2();//移除 const 限定符，提升权限使对象能作为形参上传
	//f3();//移除 const 限定符，使 const 修饰的成员函数可以修改成员
	f4();//新增const属性
	return 0;
}
```

## 修改const常变量的未定义行为

在测试过程中有这样一个案例：

```cpp
#include<iostream>
using namespace std;

int main() {
	const int a = 2;
	int* p = const_cast<int*>(&a);
	*p = 3;
	
	cout << a << endl;
	cout << *p << endl;
	
	cout << (void*)(&a) << endl;//这里为防止operator<<乱匹配，强制类型转换
	cout << (void*)p << endl;
	return 0;
}
```

输出结果之一（vs2019）：

```
2
3
001FF8C8
001FF8C8

```

常变量`a`并没有按想像中一样进行修改，而是维持原本的值。但输出这个常变量的地址，和`int*`指针捕获到的地址，会发现它们指向同一个空间。

这是一个未定义行为，`const`修饰的变量，编译器会进行一个优化：编译器认为`const`修饰的变量理论上不能被更改，于是就不会去内存中去取`const`修饰的变量，有的编译器会将常变量的值放到寄存器中甚至直接用常量去替代（类似宏）使用这个常变量的位置。这个替代常出现在打印、复合表达式中。

所以 `*p = 3;` 内存中虽然修改了，但是因为编译器的优化，常量存储的数据不受影响。

想修改这个常变量的值，可以使用`volatile`关键字，表示对常变量**不做优化**，任何时候都去内存中取常变量的值。

```cpp
#include<iostream>
using namespace std;

int main() {
	volatile const int a = 2;
	int* p = const_cast<int*>(&a);
	*p = 3;
	
	cout << a << endl;
	cout << *p << endl;
	
	cout << (void*)(&a) << endl;//这里为防止operator<<乱匹配，强制类型转换
	cout << (void*)p << endl;
	return 0;
}
```

但严格来说编译器（vs2019的MSVC）并没有将不可修改这一潜规则变成彻底的规则，这样一个漏洞是出于 ”信任程序员“ 留下的。实际使用时依旧不建议修改，因为不保证换另一个编译器不会出问题。

# dynamic_cast

`dynamic_cast`用于将一个父类对象的指针或引用转换为子类对象的指针或引用(动态转换)。一般涉及父类和子类的对象的指针或引用之间的转换称向上转型和向下转型。

## 向上转型

向上转型（向上转换）：子类对象指针或引用$\rightarrow$（指向）父类指针或引用

> 向上转型不需要转换，否则代码就编译不通过，因为转换的话会产生带常属性的临时变量，参考`double`和`int&`（`int`引用），因为继承关系有赋值兼容规则。

```cpp
#include<iostream>
using namespace std;

class A {
public:
	virtual void f() {}
	int _a = 0;
};

class B : public A {
public:
	int _b = 1;
};

int main() {
	B objb;
	A obja = objb;//继承关系下的切片赋值
	A& ra = objb;//父类的引用指向子类

	//若不是切片赋值，则会产生临时变量
	double d = 1.1;
	const int& i = d;

	return 0;
}
```

## 向下转型

向下转型（转换）：父类对象指针或引用$\rightarrow$子类指针或引用

> 向下转型本身就是不安全的，但这个操作用`dynamic_cast`转型是安全的。

父类转子类可能不行，但指针和引用可以。

子类有自己的成员和从父类继承来的成员，若原来**父类的指针本身就指向父类对象**，则这个**父类指针转换成子类指针**时可能会多访问不属于这个父类对象的数据，本身就是一个越界行为。这种越界行为是未定义行为，部分编译器不会提示。

例如，这是一个存在安全隐患的代码：

```cpp
#include<iostream>
using namespace std;

class A {
public:
	virtual void f() {}
	int _a = 0;
};

class B : public A {
public:
	int _b = 1;
};

void fun(A* pa) {
	//向下转换：直接转换是不安全的
	// 如果pa是指向父类A对象，存在越界问题
	B* ptr = (B*)pa;
	ptr->_a++;
	ptr->_b++;
}

int main() {
	A a;
	fun(&a);
	return 0;
}
```

`dynamic_cast`会阻止这种向下转换。当阻止成功时会返回0（`nullptr`）。但若是向上转换，则`dynamic_cast`会成功转换。

```cpp
#include<iostream>
using namespace std;

class A {
public:
	virtual void f() {}
	int _a = 0;
};

class B : public A {
public:
	int _b = 1;
};

void fun(A* pa) {
	B* ptr = dynamic_cast<B*>(pa);
	if (ptr) {
		ptr->_a++;
		ptr->_b++;
		cout << ptr->_a << ' '<<ptr->_b << endl;
	}
	else {
		cout << "转换失败" << endl;
	}
}

int main() {
	A a;
	fun(&a);
	B b;
	fun(&b);
	return 0;
}
```

输出：

```cpp
转换失败
1 2

```

注意：

1. `dynamic_cast`只能用于父类含有虚函数的类。
2. `dynamic_cast`会先检查是否能转换成功，能成功则转换，不能则返回0（若是指针则是`nullptr`）。
3. `dynamic_cast`对引用进行强制转换，若是转换不成功会抛异常。

## dynamic_cast的异常抛出

这个代码将演示引用方面的向上转型和向下转型。

```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class Base { public: virtual ~Base() {} };
class Derived : public Base {};

void f1() {
    // 指针转换（不抛出异常）
    Base* basePtr = new Base();
    Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
    if (derivedPtr == nullptr) {
        cout << "指针转换失败: 返回 nullptr" << endl;
    }
    delete basePtr;
}

void f2() {
    Base* basePtr = new Base();
    // 引用转换（可能抛出异常）
    Base& baseRef = *basePtr;
    try {
        //父类引用强制转换成子类引用
        Derived& derivedRef = dynamic_cast<Derived&>(baseRef);
    }
    catch (const std::bad_cast& e) {
        cout << "引用转换失败: " << e.what() << endl;
    }
    delete basePtr;
}

void f3() {
    Derived* derivePtr = new Derived();
    //子类对象的引用
    Derived& deriveRef = *derivePtr;
    try {
        //子类引用强制转换成父类引用
        Base& baseRef = dynamic_cast<Base&>(deriveRef);
        cout << "正常转换\n";
    }
    catch (const std::bad_cast& e) {
        cout << "引用转换失败: " << e.what() << endl;
    }
    delete derivePtr;
}

int main() {
    f1();
    f2();
    f3();
    return 0;
}
```

输出：

```cpp
指针转换失败: 返回 nullptr
引用转换失败: Bad dynamic_cast!
正常转换

```

强制类型转换关闭或挂起了正常的类型检查，特别是c风格的强制转换因为不做任何检查，所以安全隐患最大；c++的`cast`系列保留了部分检查，相对c风格的强制转换会更安全，但使用不当依旧存在隐患。

所以仍然建议每次使用强制类型转换前，程序员应该仔细考虑是否还有其他不同的方法达到同一目的，如果非强制类型转换不可，则应限制强制转换值的作用域，以减少发生错误的机会。强烈建议：**避免使用强制类型转换**。

# RTTI

RTTI：Run-time Type identification的简称，即：运行时类型识别。

C++通过以下方式来支持RTTI：

1. `typeid`运算符。需调用头文件`typeinfo`。

2. `dynamic_cast`运算符。

3. `decltype`关键字。


# 不定方程

不定方程又称丢番图方程。这里只讨论二元一次不定方程 $ax+by=c$ ，也就是算法竞赛常考的那部分。

不定方程 $ax+by=c$ 中 $x$ 和 $y$ 都是未知数，因此这个方程又可以转换成 $ax\equiv c\pmod b$ 。

## 裴蜀定理

裴蜀定理又称贝祖定理：

- 一定存在整数 $x, y$ ，满足 $ax + by = \text{gcd}(a, b)$ 。

可以用来判定不定方程是否存在整数解。

例如 $6x + 8y = \text{gcd}(6, 8) = 2$ ，一定有整数解。

其中 $x = -1, y = 1$ 就是一组解。

【裴蜀定理的推论】

1. 一定存在整数 $x, y$ ，满足 $ax + by = \text{gcd}(a, b) \times n$ 

因此，对于一个二元一次不定方程 $ax + by = c$ ，当 $\text{gcd}(a, b) | c$ 时，有解。

2. 一定存在整数 $x_1, x_2, x_3, \ldots$ ，满足 $a_1 x_1 + a_2 x_2 + a_3 x_3 + \ldots a_k x_k = \text{gcd}(a_1, a_2, a_3, \ldots a_k) \times n$ 。

 $a, b$ 的正负是不影响结果的。因为 $a, b$ 如果存在解，那么  $a, -b$ 也一定存在解，只不过在 $a, b$ 解的基础上添上一个负号。

因此，在用欧几里得算法求 $\text{gcd}(a, b)$ 时，为了避免出现负数，可以带入 $a, b$ 的绝对值。

## 裴蜀定理OJ示例

这个定理只给出了不定方程的解的存在，所以这个OJ考的其实是其他知识。

### 【模板】裴蜀定理 - 洛谷

[P4549 【模板】裴蜀定理 - 洛谷](https://www.luogu.com.cn/problem/P4549)

根据推论 $a_1 x_1 + a_2 x_2 + a_3 x_3 + \ldots a_k x_k = \text{gcd}(a_1, a_2, a_3, \ldots a_k) \times n$ ，方程的最小值就是求所有数的 $\text{gcd}$ 。

系数这里选择全改成正数。

```cpp
#include<bits/stdc++.h>
using namespace std;

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}

void ac() {
    int n; cin >> n;
    int ans = 1, x;
    --n; cin >> ans;
    while (n--) {
        cin >> x;
        ans = gcd(abs(ans), abs(x));
    }
    cout << ans << endl;
}

int main() {
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}

```

## 扩展欧几里得算法

对 $ax + by = \text{gcd}(a, b)$ ，当 $b = 0$ 时， $ax + by = a$ ，因此有一组解为： $x = 1, y = 0$ ；

当 $b \neq 0$ 时，

- 由欧几里得算法得： $\text{gcd}(a, b) = \text{gcd}(b, a \bmod b)$ 

- 由裴蜀定理得：
   $\text{gcd}(a, b) = ax + by$ 
  
  $\text{gcd}(b, a \bmod b) = bx_1 + (a \bmod b)y_1$ 
  $= bx_1 + (a - \frac{a}{b} \times b)y_1$ （在整数除法中存在舍弃小数部分的行为，不能约掉分母）
  $= ay_1 + b(x_1 - \frac{a}{b}y_1)$ 

因为 $\text{gcd}(a, b) = \text{gcd}(b, a \bmod b)$ ，所以：
$
\begin{cases}
x=y_1,\\
y=x_1-\frac{a}{b}y_1
\end{cases}
$

> 这组解需要根据递归和回溯过程来理解用法。

扩展欧几里得算法示例：

```cpp
//可改成其他类型，用模板是为了方便拷贝
template<class intT>
intT exgcd(intT a, intT b, intT& x, intT& y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    intT x1, y1, d;
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}
```

例如： $\text{gcd}(6,8,x,y)\rightarrow\text{gcd}(8,6,x,y)\rightarrow\text{gcd}(6,2,x,y)\rightarrow\text{gcd}(2,0,1,0)$ ，

回溯： $\text{gcd}(2,0,1,0)\rightarrow\text{gcd}(6,2,0,1)\rightarrow\text{gcd}(8,6,1,-1)\rightarrow\text{gcd}(6,8,-1,1)$ 。

所以不定方程 $6x + 8y = \text{gcd}(6, 8)$ 的1个特解是 $x=-1,y=1$ 。

于是可以利用递归，先求出下一层的 $x_1, y_1$ ，再求出当前层的  $x, y$ 。

上述递归过程，可以求出一组特解： $x_0, y_0$ 。

然后构造出通解为：
 $\begin{cases}
x = x_0 + \frac{b}{\text{gcd}(a, b)} \times k \\
y = y_0 - \frac{a}{\text{gcd}(a, b)} \times k
\end{cases}$ 
其中 $k$ 是正整数。

> 通解的构造： $a(x_0+\Delta x)+b(y_0-\Delta y)=\text{gcd}(a,b)$ ，
>
> 将左边拆开： $ax_0+by_0+a\Delta x-b\Delta y=\text{gcd}(a,b)$ ，
>
> 为了和原等式对应， $a\Delta x-b\Delta y=0$ ，所以 $\frac{\Delta x}{\Delta y}=\frac{b}{a}$ ，
>
> 将 $\frac{b}{a}$ 化简得 $\frac{\Delta x}{\Delta y}=\frac{\frac{b}{\text{gcd}(a,b)}}{\frac{a}{\text{gcd}(a,b)}}$ 。所以 $\Delta x$ 、 $\Delta y$ 可看成 $\frac{b}{\text{gcd}(a,b)}$ 和 $\frac{a}{\text{gcd}(a,b)}$ 。
>
> 为了得到无穷的通解，引入正整数 $k$ ，
>
> 所以就有通解：
>  $\begin{cases}
> x = x_0 + \frac{b}{\text{gcd}(a, b)} \times k \\
> y = y_0 - \frac{a}{\text{gcd}(a, b)} \times k
> \end{cases}$ 

时间复杂度：与欧几里得算法得时间复杂度一致，为 $O(\log n)$ 。

## 扩欧求二元一次不定方程的解

根据扩展欧几里得算法，求解二元一次不定方程 $ax + by = c$ 的解的流程：

1. 利用扩欧算法求出不定方程 $ax + by = \gcd(a, b)$ 一组特解  $x_0, y_0$ ，以及系数的最大公约数 $d$ ；

2. 由裴蜀定理判断是否有解：
   a. 如果 $d \nmid c$ （ $d$ 不是 $c$ 的约数）：无解；
   b. 如果 $d \mid c$ ：有解。

3. 如果有解：
   a. 原方程的一组特解为： $x_1 = \frac{x_0 \times c}{d}, y_1 = \frac{y_0 \times c}{d}$ ；
   
   > 根据裴蜀定理的推论， $c$ 可能不等于 $\text{gcd}(a,b)$ ，所以 $ax_0+by_0=\text{gcd}(a,b)$ ，记 $d=\text{gcd}(a,b)$ ，
   >
   > 则 $\frac{c}{d}(ax_0+by_0)=d\times\frac{c}{d}$ ，
   >
   > 所以 $a(\frac{x_0\times c}{d})+b(\frac{y_0\times c}{d})=d\times \frac{c}{d}$ ，
   >
   > 因为 $d|c$ ，所以 $a(\frac{x_0\times c}{d})+b(\frac{y_0\times c}{d})=c$ ，
   >
   > 即方程 $ax + by = c$ 的一组特解为： $x_1 = \frac{x_0 \times c}{d}, y_1 = \frac{y_0 \times c}{d}$ 。
   
   b. 根据特解可得通解： $x = x_1 + \frac{b}{\gcd(a, b)} \times k, y = y_1 - \frac{a}{\gcd(a, b)} \times k$ 。

## 扩欧定理OJ示例

### 【模板】二元一次不定方程 (exgcd) - 洛谷

[P5656 【模板】二元一次不定方程 (exgcd) - 洛谷](https://www.luogu.com.cn/problem/P5656)

> 借助这题将不定方程的解尽可能多的解释细节。

解决这个题需要使用扩欧算法解二元一次不定方程：

1. 先用`exgcd`求出 $ax+by=\text{gcd}(a,b)$ 的一组特解，记 $d=\text{gcd}(a,b)$ 。

2. $d \nmid c$ ：无解，否则有解。

3. 根据上文推论，方程 $ax + by = c$ 的一组特解为 $x_1 = \frac{x_0 \times c}{d}, y_1 = \frac{y_0 \times c}{d}$ 。利用特解可以求得通解 $x = x_1 + \frac{b}{\gcd(a, b)} \times k, y = y_1 - \frac{a}{\gcd(a, b)} \times k$ 。

   * 观察通解可发现，当 $k$ 逐渐增加， $x$ 也逐渐增加，而 $y$ 反而减小，反之同理。
     所以先将 $x$ **补正**变成**最小的正整数**，此时 $y$ 即为最大值。
   
     *  $y$ 为最大值时，当 $y\leq 0$ 时，方程无正整数解。
     *  $y$ 为最大值时，当 $y> 0$ 时，方程有正整数解。
   
     关于如何补正： $x = x_1 + \frac{b}{\gcd(a, b)} \times k$ 和 $5=1+2k$ （即 $5\bmod 2=1$ ）做比较发现十分相似，所以有 $x\bmod \frac{b}{\gcd(a, b)}=x_1$ ，此时：
     $
     x=
     \begin{cases}
     \frac{b}{\text{gcd}(a,b)},\quad x_1=0 \\[2ex]
     (x_1\bmod \frac{b}{\text{gcd}(a,b)}+\frac{b}{\text{gcd}(a,b)})\bmod \frac{b}{\text{gcd}(a,b)}, \quad x_1\neq 0
     \end{cases}
     $
     之后根据 $y=(c-ax)b$ 即可求得 $y$ 。
   
   * 当 $y\leq 0$ 时，说明方程没有全是正整数的解，题目要求输出 $x_{\min}$ 和 $y_{\min} $，其中 $y_{\min}$ 需要之前求得的最大值 $y$ 做和 $x$ 同样的操作，即补正加判断是否为0，此时即可求得 $y_{\min}$ 。
   
   * 当 $y>0$ 时，需要输出5个数。此时需要求最小的 $x_{\min}$ 和做过取模处理的 $y_{\max}$ ，以及 $x_{\max}$ 和 $y_{\min}$ 。
   
     在补正时期就求得 $x_{\min}=x$ ， $y_{\max}=y$ ，而 $y_{\min}$ 经过 $y_{\max}$ 的取模操作得到， $x_{\max}$ 通过 $\frac{(c-by)}{a}$ 得到。
   
     求有多少个正整数解，此时可以通过 $\frac{x_{\max}-x_{\min}}{\frac{b}{\gcd(a, b)}}+1$ 得到（除法得到的是等差数列之间的空隙，需要加1才能得到正整数解）。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

//可改成其他类型，用模板是为了方便拷贝
template<class intT>
intT exgcd(intT a, intT b, intT& x, intT& y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    intT x1, y1, d;
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}

void ac() {
    LL a, b, c;
    cin >> a >> b >> c;
    LL x1, y1, d;
    d = exgcd(a, b, x1, y1);
    if (c % d) {
        cout << -1 << endl;
        return;
    }
    //补正操作
    //这里需要先算c/d，因为c/d是一个整体，在整数除法顺序变了结果可能会错
    x1 = c / d * x1;
    LL g1 = b / d, g2 = a / d;//方便记录b/gcd(a,b)、a/gcd(a,b)
    x1 = (x1 % g1 + g1) % g1;
    x1 = x1 == 0 ? g1 : x1;//x_min
    y1 = (c - a * x1) / b;//y_max
    //分类讨论
    if (y1 <= 0) {
        y1 = (y1 % g2 + g2) % g2;
        y1 = y1 == 0 ? g2 : y1;
        cout << x1 << ' ' << y1 << endl;
        return;
    }
    else {
        //0表示最小值，1表示最大值
        LL x0 = x1, y0 = y1;//x_min
        y0 = (y0 % g2 + g2) % g2;
        y0 = y0 == 0 ? g2 : y0;//y_min
        x1 = (c - b * y0) / a;//x_max
        cout << (x1 - x0) / g1 + 1 << ' ' << x0 << ' ' << y0
            << ' ' << x1 << ' ' << y1 << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    cin >> T;
    while (T--)
        ac();
    return 0;
}

```



# 线性同余方程

> 同余方程的概念较为复杂，这里只举例算法竞赛常考的线性同余方程 $ax \equiv b(\text{mod } m)$ 。

竞赛中常考求一次同余方程（或线性同余方程）  $ax \equiv b(\text{mod } m)$ 的解。

或求方程 $ax\bmod m=b$ ， $b\in [0,m-1]$ 的解。

> 这个是个人根据实际应用时遇到的问题进行的补充。

例如：求 $4x \equiv 2(\text{mod } 6)$ ，其中一个解为 $x = 2$ 。

【扩欧算法求同余方程的解】

同余方程可以转换为二元一次不定方程：

- 由 $ax \equiv b(\text{mod } m)$ 可得： $ax = ym + b$ （ $ax\div m=y\dots\dots b$ ），移项得 $ax - my = b$ ；

  >  $ax \equiv b(\text{mod } m)$ 得到
  >
  >  $ax\div m=y_1\dots r$ ，
  >
  >  $b\div m=y_2\dots r$ ， $r=b-my_2$ ，代入 $ax\div m=y_1\dots r$ 有
  >
  >  $ax=my_1+b-my2=m(y_1-y_2)+b$ ，为了求 $x$ ，令 $y=y_1-y_2$ ，
  >
  > 方程变成 $ax=ym+b$ 。

- 最终目的是求 $x$ ，只有少部分情况需要求 $y$ ，所以令 $y = -y$ ，就变成熟悉的二元一次不定方程： $ax + my = b$ ；

- 由裴蜀定理得，当 $\text{gcd}(a, m) \mid b$ 时，有解。

那么，就可以用扩展欧几里得算法求出 $x$ 的值。

【扩欧算法求乘法逆元】

- 特殊的，如果 $b$ 等于 1，原方程变为 $ax \equiv 1(\text{mod } m)$ ，解出的 $x$ 实际上就是 $a$ 在模 $m$ 意义下的乘法逆元。

因此，利用扩欧算法也可以求出乘法逆元。并且不需要模数 $m$ 是质数，仅需 $\text{gcd}(a, m) = 1$ ，也就是 $a, m$ 互质即可。

## 同余方程OJ示例

### 扩欧求a的逆元 Nowcoder

[【模板】同余方程](https://ac.nowcoder.com/acm/problem/229005)

真模板题，同余方程 $ax\equiv1\pmod b$ 可转换成同余方程 $ax+by=1$ ，当 $\text{gcd}(a,b)\neq 1$ 时方程无解，否则就用扩展欧几里得算法求解。且 $x\neq 0$ 。因为 $\text{gcd}(a,b)=1$ ， $x=0$ 时，0除以任何数都为0，最大公约数不可能为1。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    LL x1, y1, d;
    d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

void ac() {
    LL a, b;
    cin >> a >> b;
    //ax %b = 1->ax+by=1
    LL x1, y1, d = exgcd(a, b, x1, y1);
    if (d != 1) {
        cout << -1 << endl;
        return;
    }
    //d=1，这里可省略
    x1 = ((x1 / d) % (b / d) + (b / d)) % (b / d);
    x1 = x1 == 0 ? b : x1;
    cout << x1 << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    cin >> T;
    while (T--)
        ac();
    return 0;
}

```

### 青蛙的约会 - 洛谷

[P1516 青蛙的约会 - 洛谷](https://www.luogu.com.cn/problem/P1516)

[1631：【例 1】青蛙的约会](http://ybt.ssoier.cn:8088/problem_show.php?pid=1631)

根据题意可得 $(x+mt)\equiv(y+nt)\pmod L$ ，例如样例：

 $(1+3t)\equiv(2+4t)\pmod 5$ ，当 $t=4$ 时成立。

这里目标是求 $t$ ，所以将方程 $(x+mt)\equiv(y+nt)\pmod L$ 转化成等式：

 $(x+mt)\bmod L=(y+nt)\bmod L$ ，因为 $x,y\leq L$ ，所以

 $x+(mt)\bmod L=y+(nt)\bmod L$ ，移项得

 $((m-n)t)\bmod L=y-x$ ，

设 $a=m-n$ ， $b=y-x$ ，则原来的方程变成

 $at\bmod L=b$ （ $at\equiv b\pmod L$ ），

所以问题变成了求 $at+Ly=b$ 这个方程的最小整数解， $t$ 的最小整数解就是答案。

但因为过程中出现很多减法，需要先进行补正操作。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    LL x1, y1, d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

void ac() {
    LL x, y, m, n, l;
    cin >> x >> y >> m >> n >> l;
    //求ax+by=c的解
    LL a = ((m - n) % l + l) % l, b = l, c = ((y - x) % l + l) % l;
    LL d = exgcd(a, b, x, y);
    if (c % d) {
        cout << "Impossible" << endl;
        return;
    }
    x = x * c / d;
    x = (x % (b / d) + (b / d)) % (b / d);
    cout << x << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}

```

# 高次同余方程

问题：给定整数 $a, b, p$ ，其中 $a, p$ 互质，求一个非负整数  $x$ ，使得 $a^x \equiv b (\text{mod } p)$ 。

该问题利用 BSGS(baby step giant step)算法求解。

> baby step gaint step，婴儿一小步，巨人一大步。

由欧拉定理的推论知 $a^{x}\equiv a^{x\bmod \varphi(x)}\pmod p$ ，因为 $\varphi(x) = x \times \frac{p_1 - 1}{p_1} \times \frac{p_2 - 1}{p_2} \times \cdots \times \frac{p_k - 1}{p_k}$ ，后面的 $\frac{p_i-i}{p_i}$ 都小于1，所以 $\varphi(x)<x$ ，理论上枚举`[1,p]`就能找到高次同余方程的解。

BSGS算法：

设 $x = im - j$ ，其中 $m = \lceil\sqrt{p}\rceil, 0 \leq j \leq m-1$ ，则方程变为 $a^{im-j} \equiv b (\text{mod } p)$ 。根据同乘性有 $(a^{m})^i \equiv b\times a^j (\text{mod } p)$ 。

1. 对于所有的 $j \in [0, m-1]$ ，把 $b \times a^j \bmod p$ 插入一个 Hash 表。

2. 枚举 $i$ 的所有可能取值，即 $i \in [0, m]$ ，计算出 $(a^m)^i \text{ mod } p$ ，在 Hash 表中查找是否存在对应的  $j$ ，存在的话更新结果 $x = im - j$ 。其中第1次出现的结果即为最小正整数解。

时间复杂度为 $O(\sqrt{p})$ 。

需要处理很多边界条件，具体在代码中实现。至于为什么会有这些边界条件，等本人到达那个境界再补充。


下面给出利用 BSGS 求解同余方程 $a^x \equiv b \text{ mod } p$ 的最小非负整数解，无解时输出 $-1$ 。

【代码实现】

```cpp
typedef long long LL;
//求a^x % p == b的解
LL BSGS(LL a, LL b, LL p) {
    a %= p; b %= p;
    if (a == 0)//a%p = b%p=0, 方程有无限多个解
        return b == 0 ? 1 : -1;
    if (b == 1)//a^0 %1 =1成立
        return 0;

    //BSGS要求a、p互质，否则a模p的乘法逆元可能不存在
    //扩展为Pohlig-Hellman 算法 或先处理公共因子
    LL x, y, d = exgcd(a, p, x, y);
    if (d > 1) {
        if (b % d)
            return -1;
        //方程转化为 (a/d)^x ≡ (b/d) * (a/d)^{-1} (mod p/d)
        p /= d;
        d = exgcd(a / d, p, x, y);
        if (d != 1)
            return -1;
        x = (x % p + p) % p;
        x = x == 0 ? p : x;//求a/d的逆元

        b = qmul(b / d, x, p);
        return BSGS(a, b, p) + 1;
    }
    map<LL, LL>mp;//键值对
    LL m = sqrt(p) + 1;

    //预处理b*a^j
    for (LL j = 0, step = b; j < m; j++) {
        if (!mp.count(step))
            mp[step] = j;
        step = qmul(step, a, p);
    }

    //预处理a^m
    LL am = 1;
    for (LL i = 1; i <= m; i++)
        am = qmul(am, a, p);

    for (LL i = 1, step = 1; i <= m; i++) {
        step = qmul(step, am, p);
        if (mp.count(step))
            return i * m - mp[step];
    }
    return -1;
}
```



## 高次同余方程OJ示例

### 模板题计算器 - 洛谷

[P2485 [SDOI2011\] 计算器 - 洛谷](https://www.luogu.com.cn/problem/P2485)

模板题，但高次同余方程需要规避很多边界条件。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    LL x1, y1, d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b % 2)
            ans = (ans + a) % m;
        a = (a * 2) % m;
        b /= 2;
    }
    return ans;
}

//求a^x % p == b的解
LL BSGS(LL a, LL b, LL p) {
    a %= p; b %= p;
    if (a == 0)//a%p = b%p=0, 方程有无限多个解
        return b == 0 ? 1 : -1;
    if (b == 1)//a^0 %1 =1成立
        return 0;

    //BSGS要求a、p互质，否则a模p的乘法逆元可能不存在
    //扩展为Pohlig-Hellman 算法 或先处理公共因子
    LL x, y, d = exgcd(a, p, x, y);
    if (d > 1) {
        if (b % d)
            return -1;
        //方程转化为 (a/d)^x ≡ (b/d) * (a/d)^{-1} (mod p/d)
        p /= d;
        d = exgcd(a / d, p, x, y);
        if (d != 1)
            return -1;
        x = (x % p + p) % p;
        x = x == 0 ? p : x;//求a/d的逆元

        b = qmul(b / d, x, p);
        return BSGS(a, b, p) + 1;
    }
    map<LL, LL>mp;//键值对
    LL m = sqrt(p) + 1;

    //预处理b^j
    for (LL j = 0, step = b; j < m; j++) {
        if (!mp.count(step))
            mp[step] = j;
        step = qmul(step, a, p);
    }

    //预处理a^m
    LL am = 1;
    for (LL i = 1; i <= m; i++)
        am = qmul(am, a, p);

    for (LL i = 1, step = 1; i <= m; i++) {
        step = qmul(step, am, p);
        if (mp.count(step))
            return i * m - mp[step];
    }
    return -1;
}

void ac(LL k) {
    LL y, z, p;
    cin >> y >> z >> p;
    if (k == 1) {
        //快速幂
        LL ans = 1;
        while (z) {
            if (z % 2)
                ans = qmul(ans, y, p);
            y = qmul(y, y, p);
            z /= 2;
        }
        cout << ans << endl;
    }
    else if (k == 2) {
        //求同余方程y*x+p*t=z
        LL x, t, d = exgcd(y, p, x, t);
        if (z % d) {
            cout << "Orz, I cannot find x!\n";
            return;
        }
        x = qmul(x, z / d, p / d);
        x = (x % p + p) % p;
        cout << x << endl;
    }
    else {
        LL ans = BSGS(y, z, p);
        if (ans == -1)
            cout << "Orz, I cannot find x!\n";
        else
            cout << ans << endl;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    LL T, K;
    cin >> T >> K;
    while (T--)
        ac(K);
    return 0;
}
```

### 模板题BSGS - 洛谷

[P3846 [TJOI2007\] 可爱的质数/【模板】BSGS - 洛谷](https://www.luogu.com.cn/problem/P3846)

还是模板题。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    LL x1, y1, d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b % 2)
            ans = (ans + a) % m;
        a = (a * 2) % m;
        b /= 2;
    }
    return ans;
}

//求a^x % p == b的解
LL BSGS(LL a, LL b, LL p) {
    a %= p; b %= p;
    if (a == 0)//a%p = b%p=0, 方程有无限多个解
        return b == 0 ? 1 : -1;
    if (b == 1)//a^0 %1 =1成立
        return 0;

    //BSGS要求a、p互质，否则a模p的乘法逆元可能不存在
    //扩展为Pohlig-Hellman 算法 或先处理公共因子
    LL x, y, d = exgcd(a, p, x, y);
    if (d > 1) {
        if (b % d)
            return -1;
        //方程转化为 (a/d)^x ≡ (b/d) * (a/d)^{-1} (mod p/d)
        p /= d;
        d = exgcd(a / d, p, x, y);
        if (d != 1)
            return -1;
        x = (x % p + p) % p;
        x = x == 0 ? p : x;//求a/d的逆元

        b = qmul(b / d, x, p);
        return BSGS(a, b, p) + 1;
    }
    map<LL, LL>mp;//键值对
    LL m = sqrt(p) + 1;

    //预处理b^j
    for (LL j = 0, step = b; j < m; j++) {
        if (!mp.count(step))
            mp[step] = j;
        step = qmul(step, a, p);
    }

    //预处理a^m
    LL am = 1;
    for (LL i = 1; i <= m; i++)
        am = qmul(am, a, p);

    for (LL i = 1, step = 1; i <= m; i++) {
        step = qmul(step, am, p);
        if (mp.count(step))
            return i * m - mp[step];
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    LL p, b, n;
    cin >> p >> b >> n;
    p = BSGS(b, n, p);
    if (p == -1)
        cout << "no solution";
    else
        cout << p << endl;
    return 0;
}
```

# 再看乘法逆元

【乘法逆元】

乘法逆元，一般用于求 $\frac{a}{b}\pmod p$ 的值。

先算出 $b$ 在模 $p$ 意义下的乘法逆元 $b^{-1}$，然后计算 $a \times b^{-1} (\text{mod } p)$ 的值，就可以将除法转化为乘法。即 $\frac{a}{b}\equiv a\times b^{-1}\pmod p$。

## 求单个元素模m的逆元

【方法一：费马小定理 + 快速幂】

- **问题**：求 $a$ 在模 $m$ 意义下的逆元。
- **前置知识回顾**：
  - 费马小定理：如果 $p$ 为质数，且 $a, p$ 互质，则 $a^{p-1} \equiv 1\pmod p$ 。
    且 $a\times a^{p-2} \equiv 1\pmod p$ ，则 $a^{p-2}$ 就是 $a$ 的模 $p$ 乘法逆元。
  - 快速幂：利用二进制和模运算特性求 $a^b\bmod m$ 的算法。

- **前提条件**： $a, m$ 互质，且 $m$ 是质数；
- **方法**：求出 $a^{m-2}\bmod m$ ，就是 $a$ 在模 $m$ 意义下的逆元。
- **时间复杂度**： $O(\log m)$ 。



【方法二：扩欧算法求逆元】

- **问题**：求 $a$ 在模 $m$ 意义下的逆元。

- **前置知识回顾**：

  - 扩展欧几里得算法的结论：对不定方程 $ax+by=\text{gcd}(a,b)$ ，可通过一下结论和递归求得不定方程的特解：

    $\begin{cases}
    x=y_1,\\
    y=x_1-\frac{a}{b}y_1
    \end{cases}$

    其中递归的边界条件是 $b=0$ ，此时 $x_1=1,y_1=0$ 。

  - 

- **前提条件**： $a, m$ 互质；

- **方法**：解同余方程 $ax \equiv 1 \pmod m$ （或 $ax\bmod m=1$ ）。将方程转换成 $ax+my=1$ ，求方程的解中 $x$ 可能得值。

- **时间复杂度**： $O(\log m)$ 。



## 递推求前n个数模p的逆元

- 问题：求 $1 \sim n$ 中所有的数在模 $p$ 意义下的逆元。

- 前提条件： $1 \sim n$ 中所有的数都与 $p$ 互质。最常见的情形是 $p>n$ 且 $\text{gcd}(n,p)=1$ 。

- 方法：线性递推：
  
  对 $1\sim n \bmod p$ ：
  
  - 当 $i = 1$ ：`inv[1] = 1`。
  
  - 当 $i > 1$ ：`inv[i] = p - (p/i) * inv[p % i] % p`。
  
    > 设 $i\in \{1,2,\dots,n\}$ ，则 $p\div i=k\dots r$ ，
    >
    > 于是 $p=i\times k+r$ ，
    >
    > 所以有 $(i\times k+r)\equiv 0\pmod p$ ，或 $(i\times k+r)\bmod p=0$ 。
    >
    > 两边同时乘 $i^{-1}\bmod p$ 和 $r^{-1}\bmod p$ 有
    >
    >  $(kr^{-1}+i^{-1})\equiv 0\pmod p$ （ $(kr^{-1}+i^{-1})\bmod p=0$ ），
    >
    > 所以 $i^{-1}\bmod p=-kr^{-1}\bmod p$ ，即 $i^{-1}\equiv (-kr^{-1})\pmod p$ 
    >
    >  $k$ 和 $r^{-1}\bmod p$ 用 $i$ 和 $p$ 代替有
    >
    >  $i^{-1}\equiv (-\frac{p}{i}\times (p\bmod i)^{-1})\pmod p$ ，或
    >
    >  $i^{-1}\bmod p=(-\frac{p}{i}\times (p\bmod i)^{-1})\bmod p$ ，为防止出现负数，进行补正操作：
    >
    >  $i^{-1}\bmod p=p-((\frac{p}{i}\times (p\bmod i)^{-1})\bmod p)$ 
    >
    > 所以根据这个递推式即可求得 $1 \sim n$ 中所有的数在模  $p$ 意义下的逆元。
  
- 时间复杂度： $O(n)$ 。



## 乘法逆元OJ示例

### 递推求前n个数模p的逆元

[P3811 【模板】模意义下的乘法逆元 - 洛谷](https://www.luogu.com.cn/problem/P3811)

套用递推式即可。但输入、输出的数据量比较大，需要对`cin`进行优化。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

void ac() {
    LL n, p;
    cin >> n >> p;
    vector<LL>inv(n + 1, 0);
    inv[1] = 1;
    for (LL i = 2; i <= n; i++) {
        //2个都可以
        inv[i] = p - ((p / i * inv[p % i]) % p);
        //inv[i] = p - p / i * inv[p % i] % p;//优先级：(* /) % (+ -)
    }
    for (LL i = 1; i <= n; i++)
        cout << inv[i] << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}

```

### 求单个元素模p的逆元

[【模板】逆元](https://ac.nowcoder.com/acm/problem/226824)

题目没保证 $p$ 是质数，因此不能用费马小定理。所以用扩展欧几里得定理求解。

这题和[【模板】同余方程](https://ac.nowcoder.com/acm/problem/229005)可以共用同一个AC的代码，准确来说是同一个题。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

//扩展欧几里得算法求不定方程的特解
LL exgcd(LL a,LL b,LL&x, LL&y){
    if(!b){
        x=1,y=0;
        return a;
    }
    LL x1,y1,d=exgcd(b,a%b,x1,y1);
    x=y1,y=x1-a/b*y1;
    return d;
}

void ac() {
    LL a,p;
    cin>>a>>p;
    //求逆元转化为求ax+py=1的解
    LL x,y,d=exgcd(a,p,x,y);
    if(d!=1){
        cout<<-1<<'\n';
        return;
    }
    x=(x+p)%p;
    cout<<x<<'\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    cin >> T;
    while (T--)
        ac();
    return 0;
}

```



# 快速读写和__int128

> 这块算是补充知识点，但仅作为高精度算法的临时替代，在有的题若使用`__int128`也会溢出，则只能用高精度算法。

虽然在 `99%` 的题目中，`scanf` 以及 `printf` 来处理输入和输出已经足够快了。但是，如果输入和输出的规模特别庞大，或者出题人卡常，`scanf` 和 `printf` 也是会超时的，这个时候就需要更加快速的读写方式。

同样的，虽然在 `99%` 的题目中，`long long` 已经足够我们应付较大的整数。但是，如果题目中数的范围过大，相乘也是有可能超过 `long long` 的最大范围。如果只是大一点点，此时可以用 `__int128` 来存储。

## 快速读写

快速读写有很多种版本，接下来要介绍一种容易实现且够用的版本 - `getchar`/`putchar` 结合秦九韶算法。

前置知识：

1. 在计算机的视角，所有的整数其实是一个一个的字符串，每个数拆开看就是一个一个字符。因此，对于一个整数，可以当成字符串，一个一个字符的输入进来。同理，输出一个整数的时候，也可以当成字符串，一个一个字符的输出。

2. `getchar`/`putchar` 这种输入输出方式相较于 `scanf`/`printf` 而言，速度更快。

于是，就可以利用 `getchar` 将字符转换成整数输入，利用 `putchar` 将整数转换成字符输出。

如果这种方式还是超时，那就把 `getchar` 换成 `getchar_unlocked`。如果换完之后还是超时，那就是毒瘤题，可以忽视，或者就是算法本身的时间复杂度有问题。

但是，`getchar_unlocked` 只能在 Linux 系统下使用，因此要慎用。

这里通过模板题进行检测：

[P10815 【模板】快速读入 - 洛谷](https://www.luogu.com.cn/problem/P10815)

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read(){
	int flag=1,ans=0;
	//这个函数只有在linux操作系统下的gcc系列编译器才能使用 
	//当然，洛谷也能使用，不然最后一个样例无法通过 
	char ch=getchar_unlocked();

	//一般编译器用这个 
//	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			flag=-1;
		ch=getchar_unlocked();
//		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar_unlocked();
//		ch=getchar();
	}
	return ans*flag; 
}

inline void print(int a){
	if(a<0){
		putchar('-');
		a=-a;
	}
	if(a>9)
		print(a/10);
	putchar(a%10+'0');
}

int main() {
	int n=read();
	int sum=0,x;
	while(n--){
		x=read();
		sum+=x;
	}
	print(sum);
    return 0;
}
```

## `__int128`

【更大的整数__int128】

`__int128` 就是占用 128 字节的整数存储类型，范围就是  $-2^{127} \sim 2^{127} - 1$ 。
即
 $-170141183460469231731687303715884105728\\\sim170141183460469231731687303715884105727$ 。

```
170 1411 8346 0469 2317 3168 7303 7158 8410 5727//39位
```

* 对比`int`的范围 $-2^{32} \sim 2^{32} - 1$ ，即 $-2147483648\sim2147483647$ 。

  无符号情况下 $0\sim 4294967295$ 。

* `long long`： $-2^{64} \sim 2^{64} - 1$ ，即 $-9223372036854775808\sim9223372036854775807$ 。

  无符号情况下 $0\sim18446744073709551615$ 。

- 如果使用了 `unsigned __int128`，则范围变成 $0 \sim 2^{128}$ ，即约 39 位数。
  $0\sim 340282366920938463463374607431768211455$ 。

当数据范围超过 `long long`，但是还不足以用上高精度算法的时候，用 `__int128` 是个不错的选择。

但是，`__int128` 是不能直接用 `cin`、`cout`、`scanf` 以及 `printf` 输入或者输出的。只能按照字符的方式输入输出，也就是我们刚刚学习的快速读写的方式。不过，当读入进来之后，用法和普通的整型变量一致。

`__int128`的使用示例（需要在gcc系IDE使用，例如Devc++）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned __int128 uint;
typedef __int128 _int;

inline void print(uint n){
	if(n>9)
		print(n/10);
	putchar(n%10+'0');
}

inline void print(_int n){
	if(n<0){
		putchar('-');
		n=-n;
	}
	if(n>9)
		print(n/10);
	putchar(n%10+'0');
}

inline _int read(){
	_int flag=1,ans=0;
	char ch=getchar();

	while(ch<'0'||ch>'9'){
		if(ch=='-')
			flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ans=ans*10+ch-'0';
		ch=getchar();
	}
	return ans*flag; 
}

void f1(){
	_int mmax=(_int(1)<<127)-1;
	print(mmax);
	cout<<endl;
	_int mmin=(_int(1)<<127);
	print(mmin+1);//无法直接输出-2^128 
	cout<<endl;
}

void f2(){
	uint mmax=~uint(0);
	print(mmax);
	cout<<endl;
}

void f3(){
	_int a=114514;
	print(a);
	cout<<endl;
	
	a=read();
	print(a);
	cout<<endl;
	
	a+=3;
	print(a);
	cout<<endl;
	
	a-=486;
	print(a);
	cout<<endl;
	
	a*=1435;
	print(a);
	cout<<endl;
	
	a/=1435;
	print(a);
	cout<<endl;
	
	a%=10007;
	print(a);
	cout<<endl;
}

int main() {
//	f1();
//	f2();
	f3();
    return 0;
}
```

`__int128` 再好用，缺陷也很多：

1. **不通用。** `__int128` 并没有在任何一个 c++ 标准中严格定义，所以目前它只是 GCC 系列编译器的专属。目前测试，只在 Linux 系统下能够正常使用，在其他编译器例如MSVC不能使用。因此如果要使用，就要看比赛中的编译器，是否是 Linux。

2. **不方便。** `__int128` 目前是不支持直接读入、输出的。也就是无法用 `cin`、`cout`、`scanf` 以及 `printf` 输入或者输出这种类型的数。只能按照字符的方式输入输出，也就是我们刚刚学习的快速读写的方式。

3. **空间大，速度慢。** `__int128` 占用了 16 个字节来存，空间超限的风险显著增加。

但是，在有些题目中，`__int128` 还是足够我们使用的。

# 中国剩余定理和线性同余方程组

引入线性同余方程组：南北朝时期《孙子算经》中有个问题：有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？

用数学公式翻译过来就是一个线性同余方程组：

$
\begin{cases} 
x \equiv 2(\text{mod } 3) \\ 
x \equiv 3(\text{mod } 5) \\ 
x \equiv 2(\text{mod } 7)
\end{cases}
$

线性同余方程组：求这个方程组的最小非负整数解。

$
\begin{cases} 
x \equiv r_1(\text{mod } m_1) \\ 
x \equiv r_2(\text{mod } m_2) \\ 
\vdots \\ 
x \equiv r_n(\text{mod } m_n)
\end{cases}
$
## 中国剩余定理(CRT)

前提：所有的模数 $m_1, m_2, ..., m_n$ 两两互质。因此中国剩余定理的使用比较局限。

原理：中国剩余定理是基于“构造法”得出的结果。以下给出 $n = 3$ 的构造过程， $n$ 等于任意数的构造过程是一样的。

对于这个方程组： 

$\begin{cases} x \equiv r_1 (\text{mod } m_1) \\ x \equiv r_2 (\text{mod } m_2)\\x \equiv r_3 (\text{mod } m_3) \end{cases}$ 

或

$\begin{cases}x\bmod m_1=r_1\\x\bmod m_2=r_2\\x\bmod m_3=r_3\end{cases}$ 

记 $M = m_1 \times m_2 \times m_3$ ，构造解： $x = C_1 + C_2 + C_3$ ，其中：

*  $C_1 \text{ mod } m_1 = r_1,\ C_1 \text{ mod } m_2 = 0,\ C_1 \text{ mod } m_3 = 0$ 

*  $ C_2 \text{ mod } m_1 = 0, \ C_2 \text{ mod } m_2 = r_2, \ C_2 \text{ mod } m_3 = 0 $ 

*  $C_3 \text{ mod } m_1 = 0, \ C_3 \text{ mod } m_2 = 0, \ C_3 \text{ mod } m_3 = r_3$ 

> 这样 $x\bmod m1 = C_1\bmod m1+C_2\bmod m1+C_3\bmod m_1=r_1$ ，其他 $m2$ 、 $m3$ 同理。
>
> 因此只要能构造出这样的 $x$ ，那么 $x$ 就是我们要的解。

 $C_1$ 、 $C_2$ 和 $C_3$ 的构造方式： 

*  $C_1 = r_1 \times m_2 \times m_3 \times (m_2 \times m_3)^{-1},$ 

  >  $(m_2 \times m_3)^{-1}$ 为模 $m_1$ 意义下的逆元， $m_2 \times m_3 \times (m_2 \times m_3)^{-1}\bmod m_1$ 最后的结果是1。所以 $C_1\bmod m_1=r_1$ ， $C_1\bmod m_2=C_1\bmod m_3=0$ 。

*  $C_2 = r_2 \times m_1 \times m_3 \times (m_1 \times m_3)^{-1},$  其中 $(m_1 \times m_3)^{-1}$ 为模 $m_2$ 意义下的逆元。

*  $C_3 = r_3 \times m_1 \times m_2 \times (m_1 \times m_2)^{-1}, $ 其中 $(m_1 \times m_2)^{-1}$ 为模 $m_3$ 意义下的逆元。

当 $x$ 加减 $M$ 的若干倍时，依旧是满足方程，因此最小非负整数解就是
 $(x \text{ mod } M + M) \text{ mod } M$ 。

整个方程的通解是 $x+kM$ 。

以《孙子算经》中的问题为例： 
 $\begin{cases} x \equiv 2(\text{mod } 3) \\ x \equiv 3(\text{mod } 5) \\ x \equiv 2(\text{mod } 7) \end{cases}$ 

1. 计算每一个方程的 $C_i$ ： 
$C_1 = r_1 \times m_2 \times m_3 \times (m_2 \times m_3)^{-1} = 2 \times 5 \times 7 \times 35^{-1}(\text{mod } 3) = 2 \times 5 \times 7 \times 2 = 140$
$C_2 = r_2 \times m_1 \times m_3 \times (m_1 \times m_3)^{-1} = 3 \times 3 \times 7 \times 21^{-1}(\text{mod } 5) = 3 \times 3 \times 7 \times 1 = 63$
$C_3 = r_3 \times m_1 \times m_2 \times (m_1 \times m_2)^{-1} = 2 \times 3 \times 5 \times 15^{-1}(\text{mod } 7) = 2 \times 3 \times 5 \times 1 = 30$ 

2. 计算结果： $x = (140 + 63 + 30) \text{ mod } 105 = 233 \text{ mod } 105 = 23$ 

**推广**： $n$ 取任意数的时候，构造方式也是同理。  

-  $C_1 = r_1 \times m_2 \times m_3 \times \ldots \times m_n \times (m_2 \times m_3 \times \ldots \times m_n)^{-1}$ , 
-  $C_2 = r_2 \times m_1 \times m_3 \times \ldots \times m_n \times (m_1 \times m_3 \times \ldots \times m_n)^{-1}$ ,  
-  $\ldots$   
-  $C_n = r_n \times m_1 \times m_2 \times \ldots \times m_{n-1} \times (m_1 \times m_2 \times \ldots \times m_{n-1})^{-1} $。  

当 $m_1, m_2, \ldots, m_n$ 两两互质时，一定存在这样的 $C_1, C_2, \ldots, C_n$ ，因为对应的逆元是一定存在的。且通解为： $X = k \times \text{lcm} + x$ ，其中 $\text{lcm}$ 因为 $m_i$ 全是质数，所以实际相当于整体的乘积。



**总结**：在算法竞赛中，中国剩余定理应用的算法流程：

1. 计算所有模数的乘积 $M = m_1 \times m_2 \times \ldots \times m_n$ ；

2. 计算第 $i$ 个方程的 $c_i = \frac{M}{m_i}$ ；

3. 计算 $c_i$ 在模 $m_i$ 意义下的逆元 $c_i^{-1}$（扩欧算法）；

4. 最终解为 $x = \sum_{i=1}^n r_i c_i c_i^{-1} (\text{mod } M)$ 。



## 中国剩余定理OJ示例

### 模板题曹冲养猪 - 洛谷

[P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪 - 洛谷](https://www.luogu.com.cn/problem/P1495)

[1634：【例 4】曹冲养猪](http://ybt.ssoier.cn:8088/problem_show.php?pid=1634)

CRT的模板题，因为数据量大，需要使用快速幂改装的龟速乘算法来进行最后的求乘。

龟速乘是能一步出结果的乘法，拆分成若干步乘完，这样做能最大程度保证不溢出，但牺牲了速度。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

//扩展欧几里得算法
void exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return;
    }
    LL x1, y1;
    exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
}

//龟速乘，防溢出
LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b % 2)
            ans = (ans%m + a%m) % m;
        a = (a + a) % m;
        b /= 2;
    }
    return ans;
}

void ac() {
    LL n;
    cin >> n;
    vector<LL>r(n + 1, 0), m(n + 1, 1);
    for (LL i = 1; i <= n; i++)
        cin >> m[i] >> r[i];

    //中国剩余定理
    LL M = 1;
    for (auto& x : m)
        M *= x;

    LL ans = 0;
    for (LL i = 1; i <= n; i++) {
        LL ci = M / m[i];
        LL x, y;
        exgcd(ci, m[i], x, y);
        x = (x % m[i] + m[i]) % m[i];
        //快速幂改装的鬼速乘算法
        ans = (ans % M + qmul(qmul(r[i], ci, M), x, M)) % M;
    }
    cout << ans << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}

```

### 模板题猜数字 - 洛谷

[P3868 [TJOI2009\] 猜数字 - 洛谷](https://www.luogu.com.cn/problem/P3868)

中国剩余定理的推广模板。题目要求的是 $b_i\mid (n-a_i)$ ，即 $(n-a_i)\bmod b_i=0$ ，将等式拆分开就是 $n\bmod b_i-a_i\bmod b_i=0$ ，即 $n\equiv a_i\pmod {b_i}$ 。

因此题目要求的就是同余方程组 $n\equiv a_i\pmod {b_i}$ 的解， $n$ 是未知数。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

void exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return;
    }
    LL x1, y1;
    exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
}

LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b % 2)
            ans = (ans + a) % m;
        a = (a * 2) % m;
        b /= 2;
    }
    return ans;
}

void ac() {
    int n;
    cin >> n;
    vector<LL>a(n + 1, 1), b(a);
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    LL M = 1;
    for (int i = 1; i <= n; i++)
        cin >> b[i], M *= b[i];

    //CRT推广
    LL ans = 0;
    for (int i = 1; i <= n; i++) {
        LL ci = M / b[i];
        LL x, y;
        exgcd(ci, b[i], x, y);
        x = (x % b[i] + b[i]) % b[i];
        //a[i]为负数，需要放第1个形参，否则会死循环
        ans = (ans + qmul(qmul(a[i], ci, M), x, M) + M) % M;
    }
    cout << ans << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}
```



## 扩展中国剩余定理

中国剩余定理只能处理所有模数两两互质的情况，如果模数不互质，CRT就不适用了。

【扩展中国剩余定理 - EXCRT】

同样是求线性同余方程组：

$\begin{cases} 
x \equiv r_1 (\text{mod } m_1) \\ 
x \equiv r_2 (\text{mod } m_2) \\ 
\vdots \\ 
x \equiv r_n (\text{mod } m_n)
\end{cases}$

思路是将任意整数 $X$ 不断迭代成最终解。

这里补充一个方程： $x \equiv r_0 (\text{mod } m_0)$，其中 $r_0 = 0, m_0 = 1$ 。

设最终的通解为： $ret = x \times m_0 + r_0$，初始时 $m_0 = 1, r_0 = 0$ 。

然后依次迭代后面的方程，使的最终解 $ret$ 依次满足后续的方程。

设当前取的方程为： $x \equiv r_i (\text{mod } m_i)$ ，即 $ret = y \times m_i + r_i$ 

1. 根据两式右边相等： $ret = x \times m_0 + r_0 = y \times m_i + r_i$ ,

2. 于是： $x \times m_0 - y \times m_i = r_i - r_0$ ,

3. 形如 $ax + by = c$ ，其中 $a = m_0, b = m_i, c = r_i - r_0$ 

4. 根据扩欧算法，可以解出特解 $x_0, y_0$ 。（如果无解，算法结束）

5. 通解为 $x = x_0 + \frac{b}{d} \times k$ ，代入最终解中： $ret = (x_0 + \frac{b}{d} \times k) \times m_0 + r_0$ 

6. 整理得： $ret = k(\frac{b}{d} \times m_0) + (x_0 \times m_0 + r_0)$ ，既满足之前的方程，也满足当前方程。

其中新的 $m' = \frac{b}{d} \times m_0, r' = x_0 \times m_0 + r$ 

7. 利用 $ret$ 的表达式继续迭代下一个方程。直到迭代完所有的方程或某个方程无解为止。

例如：

$\begin{cases}
x \equiv 2(\text{mod } 3) \\
x \equiv 3(\text{mod } 5) \\
x \equiv 2(\text{mod } 7)
\end{cases}$

补上一个方程 $x \equiv 0 (\text{mod } 1)$ ，最终解 $ret = x \times 1 + 0$ 

迭代第一个方程： $ret = y \times 3 + 2$ 

*  $ret = x \times 1 + 0 = y \times 3 + 2$ ，即 $x - 3y = 2$ ，也可看做 $x + 3y = 2$ 。

* 利用扩欧算法得

 $\begin{cases}x=2+3k\\y=0-k\end{cases}$ 

* 此时 $ret=k\times 3+2$ 满足第一个方程。 $k$ 是整数，在后续迭代中也可看成新的未知数。

迭代第二个方程： $ret = y \times 5 + 3$ 

*  $ret = x \times 3 + 2 = y \times 5 + 3$ ，即 $3x + 5y = 1$ 

* 利用扩欧算法解得： 
   $\begin{cases} 
  x = 2 + 5 \times k \\ 
  y = -1 - 3 \times k 
  \end{cases}$ 
* 于是将 $x$ 的通解代入 $ret$ 中得： $ret = k \times 15 + 8$ 。此时 $ret$ 满足前两个方程。

迭代第三个方程： $ret = y \times 7 + 2$ 

*  $ret = x \times 15 + 8 = y \times 7 + 2$ ，即 $15x + 7y = -6$ 

* 利用扩欧算法解得：
  $\begin{cases} 
  x = -6 + 7 \times k \\ 
  y = 12 - 15 \times k 
  \end{cases}$
* 代入 $ret$ 中得： $ret = k \times 105 - 82 = k \times 105 + 23$ 。

此时 $ret$ 满足所有方程，并且 $23$ 为最小非负整数解。



## 扩展中国剩余定理OJ示例

之前的OJ例如[P1495 【模板】中国剩余定理（CRT）/ 曹冲养猪 - 洛谷](https://www.luogu.com.cn/problem/P1495)、[P3868 [TJOI2009\] 猜数字 - 洛谷](https://www.luogu.com.cn/problem/P3868)也能用扩展中国剩余定理解决。

### 模板题扩展中国剩余定理（EXCRT） - 洛谷

[P4777 【模板】扩展中国剩余定理（EXCRT） - 洛谷](https://www.luogu.com.cn/problem/P4777)

需要注意的点是，构造的方程 $ax+by=c$ 中 $c$ 需要为最小整数，以及利用 $ax+by=\text{gcd}(a,b)$ 求方程 $ax+by=c$ 的特解时，需要使用龟速乘算法，这些都是为防止溢出需要做的操作。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    LL x1, y1, d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b & 1)
            ans = (ans + a) % m;
        a = (a * 2) % m;
        b >>= 1;
    }
    return ans;
}

void ac() {
    int n;
    cin >> n;
    vector<LL>a(n + 1, 0), b(a);
    for (int i = 1; i <= n; i++)
        cin >> a[i] >> b[i];

    //扩展中国剩余定理
    //ret = k*m+r
    LL m = 1, r = 0;
    for (int i = 1; i <= n; i++) {
        //解不定方程mx+a[i]y=b[i]-r
        LL x, y, d = exgcd(m, a[i], x, y), c = b[i] - r;
        c = (c % a[i] + a[i]) % a[i];
        if (c % d) {
            cout << -1 << endl;
            return;
        }
        y = a[i] / d;//y是不定方程的另一个解，不重要，于是代码复用
        //加龟速乘，擦边通关OJ
        x = qmul(x, c / d, y);
        x = (x % y + y) % y;
        r = x * m + r;
        m = y * m;
        r = (r % m + m) % m;//ret = k*m+r，可以用m对r进行范围限制
    }
    cout << r << endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    //cin >> T;
    while (T--)
        ac();
    return 0;
}

```

### NOI2018 屠龙勇士

[P4774 [NOI2018\] 屠龙勇士 - 洛谷](https://www.luogu.com.cn/problem/P4774)

> 这种个人感觉是真正的压轴题或准压轴题级别的题，题目又臭又长，还得逐句分析，其中分析还得分阶段，严重的还有分类谈论，每个阶段的分析还得有联系，不然无法流畅地翻译成自然语言或代码。
>
> 在实现时往往伴随着知识点的嵌套使用，极其考验综合能力。

读题：

首先是游戏规则：

1. 1条龙，打它会使Hp会变负数，然后回血，Hp恢复到0时龙死去，否则不能死去。

   例如龙的初始Hp为 5，将血量斩杀到 -4，龙的回血 $p=2$ ，回 2 次后龙会死去；或刚好砍到Hp位0，则龙死去。

   但如果某几次攻击将血量斩杀到-3，龙回血2次后血量变成1，龙就还能蹦迪。

   所以选择的武器需要将龙的血量控制在$p$的整数倍才能击杀。

2. 砍龙需要选剑，砍死龙得新剑。

然后这人想写个脚本之类的东西挂机刷游戏，脚本原理：

1. 选择当前有的、伤害不大于龙Hp、同时伤害是最大的剑。没有就选伤害最小的。

   例如Hp = 5，剑$a[i]=\{1,2,3,4,4,5,6,7,8,9\}$，此时选`a[5]=5`的剑。

   剑 $a[i]={6,7}$ ，此时选`a[0]=6`的剑。

2. 对每条龙，设置固定的攻击次数 $x$ 。

之后就是解题思路：

1. 确定哪条龙用哪把剑。

   既然要选剑，则剑应该有序，想到**排序**。

   对每条龙，考虑Hp和奖励，在剑的集合中选**不大于龙的血量且伤害最大的**，首先应该想到**二分**优化的枚举，二分的话要考虑数组，数组需要看**数据量**是否支持。

   因为有消耗和奖励，需要**频繁插入和删除还有取出指定位置的剑**，想到集合`multiset`，插入和取出都是 $O(\log n)$ 。可以选择用`upper_bound`快速查找，但要注意这个成员函数找的是大于Hp的最小值，所以需要使返回的迭代器减1，边界情况是所有剑都大于Hp。

2. 如何确定攻击次数 $x$ 。

   根据题意解读的每条龙的信息`{初始血量Hp,恢复rv,剑的伤害swd,打的次数x,恢复次数y}`，根据游戏规则构造等式 $Hp-swd\times x+rv\times y=0$ ，即 $swd\times x=rv\times y+Hp$ ，看到这个等式想到
   $swd\times x\div rv=y\dots Hp$ ，2个等式 $swd\times x=rv\times y+Hp$ 和 $swd\times x\div rv=y\dots Hp$ 中， $y$ 也是未知数，所以根据这2个等式可得出**同余方程** $swd\times x\equiv Hp\pmod {rv}$。

   对所有龙的**同余方程组**：

   $\begin{cases}swd_1x\equiv Hp_1\pmod {rv_1}\\swd_2x\equiv Hp_2\pmod {rv_2}\\\dots\\swd_nx\equiv Hp_n\pmod {rv_n}\end{cases}$ 

   解出 $x$ 的，即为攻击次数。和之前的同余方程组不同，这个方程组的**未知数带系数**，使用**扩展中国剩余定理**时需要注意细节。

   * 扩展中国剩余定理解同余方程组：

     约定攻击次数 $ret$ ，恢复力 $m=rv$ ， $r=Hp$ 。

     设方程 $ret=km+r$ ， $m=1$ ， $r=0$ 。

     对任一方程 $swd\times x\equiv Hp\pmod {rv}$ ，其实就是 $swd\times ret=y\times rv+Hp$ ，次数 $x$ 换成了 $ret$ ，都表示攻击次数。

     联立：

     $\begin{cases}ret=km+r\\swd\times ret=y\times rv+Hp\end{cases}$

     第1个方程左右同时乘 $swd$ 消去 $ret$ ，并移项得

     $swd\times m\times k+y\times rv=Hp-swd\times r$ ，此时得到一个**不定方程**，

     对比 $Ax+By=C$ ， $A=swd\times m$ ， $B=rv$ ， $C=Hp-swd\times r$ 。

     之后就是熟悉的流程：**扩展欧几里得算法** 求$k$（或者说$x$）的通解，代入 $ret=km+r$ 得到新的 $m$ 和 $r$ ，并用它们继续迭代其他方程。

     对比之前的扩展中国剩余定理，多个常数系数时只需要联立方程组即可解决。

   * 细节问题：

     * **防溢出**。

       在乘法阶段用**龟速乘算法**代替。同时对方程 $swd\times x\equiv Hp\pmod {rv}$ ， $swd\times x$ 和 $Hp$ 可以都同时先模 $m$ 限制大小，即 $(swd\times x\bmod rv)\equiv {(Hp\bmod rv)}\pmod {rv}$ 。其他地方能取模尽量**取模**。

     * 最终结果 $ret=km+r$ 中的 $r$ 可能不是正确答案，而是只是方程组的解，此时还需要 $y>0$ 也就是恢复次数也要大于0。

       此时对于每条龙的血量 $Hp$ 和剑的伤害 $swd$ ，在求攻击次数时需为 $\lceil\frac{Hp}{swd}\rceil$。例如Hp为5的龙，伤害为2的剑，攻击次数需要为 $\lceil\frac{5}{2}\rceil=3$ ，才能压血线到负数。

       同时需要将每条龙斩到负数Hp的攻击次数并不完全相同，此时需要取最大的次数，取**方程中攻击次数大于最大攻击次数的特解**，才能保证将所有的龙的血量砍到负数。这里假设所有龙中需要被砍的最多的次数为 $\text{max\_tm}$ ， $\text{max\_tm}=\lceil\frac{\text{Hp}}{\text{swd}}\rceil$ 。

       对表示攻击次数的方程 $ret=km+r$ ，需有 $ret\geq \text{max\_tm}$ 。

       * $r\geq \text{max\_tm}$ ，此时$ ret=r$ 。

       * $r<\text{max\_tm}$ ，此时 $ret=\lceil\frac{\text{max\_tm}-r}{m}\rceil\times m+r$ 。

         这里 $\lceil\frac{\text{max\_tm}-r}{m}\rceil$ 表示需要在最小正整数解的基础上增加的模数$m$的数量，这样做是为了求能以最低的固定攻击次数将所有的龙都压到负数Hp的特解。

参考程序（变量名和数组名与分析对应）：

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

LL exgcd(LL a, LL b, LL& x, LL& y) {
    if (!b) {
        x = 1; y = 0;
        return a;
    }
    LL x1, y1, d = exgcd(b, a % b, x1, y1);
    x = y1; y = x1 - a / b * y1;
    return d;
}

LL qmul(LL a, LL b, LL m) {
    LL ans = 0;
    while (b) {
        if (b % 2)
            ans = (ans + a) % m;
        a = (a * 2) % m;
        b /= 2;
    }
    return ans;
}

void ac() {
    int N, M;
    cin >> N >> M;
    //Hp血量，rv恢复，rd reword奖励,swd sword砍龙时用的剑
    vector<LL>Hp(N + 1, 0), rv(Hp), rd(Hp),swd(Hp);
    multiset<LL>st;
    LL max_tm = 0;//max times，最难砍的龙需要的次数
    
    for (int i = 1; i <= N; i++)
        cin >> Hp[i];
    for (int i = 1; i <= N; i++)
        cin >> rv[i];
    for (int i = 1; i <= N; i++)
        cin >> rd[i];
    for (int i = 1; i <= M; i++) {
        LL x; cin >> x;
        st.insert(x);
    }

    //选择剑
    for (int i = 1; i <= N; i++) {
        //二分
        auto it = st.upper_bound(Hp[i]);
        if (it != st.begin())
            --it;
        swd[i] = *it;
        max_tm = max(max_tm, (Hp[i] + swd[i] - 1) / swd[i]);
        st.erase(it);
        st.insert(rd[i]);
    }
    //确定攻击次数
    //扩展中国剩余定理，初始方程ret=mx+r，m是rv，r是hp，res是攻击次数
    //对应同余方程（组）swd*x % rv = Hp
    LL m = 1, r = 0;
    for (int i = 1; i <= N; i++) {
        //Hp-swd*x+rv*y=0 得到同余方程
        //联立ret=mx+r和Hp-swd*x+rv*y=0
        //得到不定方程 (swd*m) x + rv* y= Hp-swd*r
        LL A = qmul(swd[i] ,m,rv[i]), B = rv[i], C = Hp[i] - swd[i] * r;
        C = (C % B + B) % B;
        LL x, y, d = exgcd(A, B, x, y);
        if (C % d) {
            cout << -1 << endl;
            return;
        }
        LL g1 = B / d;
        x = qmul(x,C / d,g1);
        x = (x % g1 + g1) % g1;
        r = r + x * m;
        m = g1 * m;
        r = (r % m + m) % m;
    }
    //最小正整数解可能无法将所有的龙都砍到负数Hp需要求特解
    if (r < max_tm)
        r = r + (max_tm - r + m - 1) / m * m;
    cout << r<<endl;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T = 1;
    cin >> T;
    while (T--)
        ac();
    return 0;
}
```




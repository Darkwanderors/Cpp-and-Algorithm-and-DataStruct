# 分治思想

所谓分治就是指分而治之，即**将较大规模的问题分解成几个较小规模的问题**，通过**对较小规模问题的求解达到对整个问题的求解**。之前将问题分解成两个较小问题求解时的分治方法称之为二分法。

类比的话就是某校校长想知道全校有多少学生，可以问学校各个部门的领导，领导们再问各个办公室的老师，老师再问各个班级的班长，班长在统计之后将数字向老师汇报，老师再向领导汇报，领导对数据处理之后返回给校长。即：将工作分摊给其他单位去做。

## 循环比赛日程表

题目链接：[1325：【例7.4】 循环比赛日程表](http://ybt.ssoier.cn:8088/problem_show.php?pid=1325) 

以$M=3$（即$N=2^3=8$）为例，可以根据问题要求，制定出如下表所示的一种方案：

```
A:1 2 3 4  B:5 6 7 8
  2 1 4 3    6 5 8 7
  3 4 1 2    7 8 5 6
  4 3 2 1    8 7 6 5

C:5 6 7 8  D:1 2 3 4
  6 5 8 7    2 1 4 3
  7 8 5 6    3 4 1 2
  8 7 6 5    4 3 2 1
```

以表格的中心为拆分点，将表格分成A、B、C、D四个部分，就很容易看出有`A==D`，`B==C`，B对应A同样的位置的值加上A的边长。并且，这一规律同样适用于各个更小的部分。

则可以将表格细分得不能再细分，对每一个被细分后的部分以同样的方法拆分，之后先求出A，再通过统一循环求B, C，最后求B。

方法很多，可以通过两层循环控制，也可以通过递归。这里使用递归：

```cpp
#define _CRT_SECURE_NO_WARNINGS 1

#include<iostream>
using namespace std;

const int MAXN = 1025;
int player[MAXN][MAXN];
int two[11];
int m;

int pow2(int num) {//求2的num次幂，数据范围小不用高精度 
	if (num == 0) {
		two[num] = 1;
		return 1;
	}
	if (two[num])//记忆化处理
		return two[num];
	int ans = 1, tnum = num;//answer,temporary num
	while (num) {
		ans *= 2;
		num--;
	}
	two[tnum] = ans;
	return ans;
}

void solve(int num) {//递归实现分治思维
	if (num == 0)
		return;
	solve(num - 1);//递归处理 
	if (num == 1) {//最小的A单元额外处理
		player[1][1] = 1;
		player[1][2] = 2;
		player[2][1] = 2;
		player[2][2] = 1;
		return;
	}
	for (int i = 1; i <= pow2(num - 1); i++)//求B、C
		for (int j = pow2(num - 1) + 1; j <= pow2(num); j++) {
			player[i][j] = player[i][j - pow2(num - 1)] + pow2(num - 1);
			player[j][i] = player[j - pow2(num - 1)][i] + pow2(num - 1);
		}
	for (int i = 1; i <= pow2(num - 1); i++)//求D
		for (int j = 1; j <= pow2(num - 1); j++) {
			player[i + pow2(num - 1)][j + pow2(num - 1)] = player[i][j];
			player[j + pow2(num - 1)][i + pow2(num - 1)] = player[j][i];
		}
}

int main() {
	ios::sync_with_stdio(false);
	cin >> m;
	solve(m);
	for (int i = 1; i <= pow2(m); i++) {
		for (int j = 1; j <= pow2(m); j++)
			cout << player[i][j] << ' ';
		cout << '\n';
	}
	return 0;
}
```



## 黑白棋子的移动

题目链接：[P1259 黑白棋子的移动 - 洛谷](https://www.luogu.com.cn/problem/P1259)

只看前几步的话可以看到移动方法是一样的：将中间的`o*`移动到空格处，再将`**`移动到新形成的空格。看起来就像是将`o*`后移。

除了最后5步移动是固定的。这也是为什么$n\geq4$的原因。

发现规律后，便可通过模拟移动棋子。方法很多，可以是递归，也可以是循环枚举，还可以是dfs。

循环枚举参考程序：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
char pct[201];
int n;
int space;//记录空格的位置 

void print(){//打印当前移动后的结果
	for(int i=1;i<=2*n+2;i++)
		cout<<pct[i];
	cout<<endl;
}

void mv(int pos){//移动棋子 
	for(int i=0;i<=1;i++){
		pct[space+i]=pct[pos+i];
		pct[pos+i]='-';
	}
	space=pos;//更新空格位置 
	print();
}

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		pct[i]='o';
		pct[i+n]='*';
	}
	for(int i=2*n+1;i<=2*n+2;i++)
		pct[i]='-';
	space=2*n+1;
	print();
	
	int times=n;
	while(times>4){
		mv(times);mv(2*times-1);
		--times;
	}
	mv(4);mv(8);mv(2);mv(7);mv(1);//最后黑白棋各自只剩4个没归位时单独移动 
	
    return 0;
}
```

除了这些，快速排序、归并排序和快速幂等也用到了分治的思想。

快速幂是求$(a^b)\%n$的值的一种算法，和高精度计算搭配使用。

## P10446 64位整数乘法 - 洛谷

[P10446 64位整数乘法 - 洛谷](https://www.luogu.com.cn/problem/P10446)

快速幂模板题。

先说最优雅的解法：python。

```py
a, b, p = int(input()), int(input()), int(input())
print(a*b%p)

```

然后就是分治。

模拟快速幂算法，根据$(a+b)\bmod p=(a\bmod p+b\bmod p)\bmod p$，将$a+b$逐步变成
$0+a=a$
$2a\bmod p=(a+a)\bmod p$
$4a\bmod p=(2a+2a)\bmod p$
$8a\bmod p=(4a+4a)\bmod p$
$\cdots$

其中加上哪些项取决于$b$的哪些二进制位为1。这种算法在数学有关的竞赛题中称为龟速乘。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll qsum(ll a, ll b, ll p) {
	ll sum = 0;
	while (b) {
		if (b % 2LL)
			sum = (sum + a) % p;
		a = (a + a) % p;
		b /= 2LL;
	}
	return sum;
}
void ac() {
	ll a, b, p;
	cin >> a >> b >> p;
	printf("%lld", qsum(a, b, p));
}

int main() {
	int T = 1;
	//cin>>T;
	while (T--)
		ac();
	return 0;
}
```



## 求逆序对

[P1908 逆序对 - 洛谷](https://www.luogu.com.cn/problem/P1908)

关于逆序对，我在[内排序中的归并排序-CSDN博客](https://blog.csdn.net/m0_73693552/article/details/143898850)中有介绍。

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
typedef long long ll;
ll cnt = 0;

void merge(vector<int>& a, vector<int>& b, int l, int r) {
	if (l >= r)
		return;
	int mid = (l + r) / 2, bg1 = l, ed1 = mid, bg2 = mid + 1, ed2 = r;
	merge(a, b, bg1, ed1);
	merge(a, b, bg2, ed2);
	int i = bg1;
	while (bg1 <= ed1 && bg2 <= ed2) {
		if (a[bg1] <= a[bg2])
			b[i++] = a[bg1++];
		else {
			b[i++] = a[bg2++];
			cnt = cnt + ed1 - bg1 + 1;
		}
	}
	while (bg1 <= ed1)
		b[i++] = a[bg1++];
	while (bg2 <= ed2)
		b[i++] = a[bg2++];
	for (i = l; i <= r; i++)
		a[i] = b[i];
}

void merg(vector<int>& a, int l, int r) {
	vector<int>b(a.size(), 0);
	merge(a, b, l, r);
}

int main() {
	cin >> n;
	vector<int>a(n,0);
	for (int i = 0; i < n; i++)
		cin >> a[i];
	merg(a, 0, n - 1);
	cout << cnt;
	return 0;
}
```





[P1923 【深基9.例4】求第 k 小的数 - 洛谷](https://www.luogu.com.cn/problem/P1923)



[P1115 最大子段和 - 洛谷](https://www.luogu.com.cn/problem/P1115)



[P1228 地毯填补问题 - 洛谷](https://www.luogu.com.cn/problem/P1228)








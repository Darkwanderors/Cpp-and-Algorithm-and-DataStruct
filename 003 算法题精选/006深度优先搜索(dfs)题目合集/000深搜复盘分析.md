# 20250614 小木棍 剪枝多处错误

[T587416 小木棍 - 洛谷](https://www.luogu.com.cn/problem/T587416)


```cpp
#include<bits/stdc++.h>
using namespace std;

int a[51];
int n;
int mmax = 0, sum = 0, num = 0;
bool flag = 0;

void dfs(int& std_len, int now_len, int num, int last_len) {
	if (flag)
		return;
	if (now_len == std_len) {//说明找到了一组
		if (!num) {
			flag = 1;
			return;
		}
		if (num)
			dfs(std_len, 0, num, mmax);
		return;
	}
	//问题3，当前木棍使用时，之前的木棍都比现在长或短，应剪枝
	for (int i = last_len; i > 0; i--)//问题2搜索顺序优化，但也没全优化，这里正向枚举
		if (a[i]) {
			if (std_len < now_len + i)
				continue;
			a[i]--;
			dfs(std_len, now_len + i, num - 1, i);
			a[i]++;
			if (flag || now_len + i == std_len || now_len == 0)//问题4，不够细心，没能想到回溯时会有已经找到一组或还没找到，now_len为0的情况。
				return;
		}
}

void ac() {
	cin >> n;
	for (int i = 1, x; i <= n; i++) {
		cin >> x;
		a[x]++;
		mmax = max(mmax, x);
		sum += x;
	}
	num = n;
	for (int i = mmax; i <= sum; i++) {
		if (sum % i == 0)//问题1，没看题
			dfs(i, 0, num, mmax);
		if (flag) {
			cout << i;
			return;
		}
	}
}

int main() {
	int T = 1;
	//cin >> T;
	while (T--)
		ac();
	return 0;
}
```

另一种解法：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[61];
bool vis[61];
int mmax, sum;

void dfs(int std_len, int now_len, int num) {
	if (std_len == now_len) {
		if (!num) {
			cout << std_len;
			exit(0);
		}
		dfs(std_len, 0, num);
		return;
	}

	for (int i = n; i > 0; i--) {
		if (vis[i])
			continue;
		if (now_len + a[i] > std_len)//可行性剪枝
			continue;
		vis[i] = 1;
		dfs(std_len, now_len + a[i], num - 1);
		vis[i] = 0;
		if (now_len + a[i] == std_len || now_len==0)//排除等效冗余
			return;
	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		mmax = max(a[i], mmax);
		sum += a[i];
	}
	sort(a + 1, a + n + 1);//优化搜索顺序
	for (int i = mmax; i <= sum; i++) {
		if (sum % i == 0)
			dfs(i, 0, n);
	}
	return 0;
}
```


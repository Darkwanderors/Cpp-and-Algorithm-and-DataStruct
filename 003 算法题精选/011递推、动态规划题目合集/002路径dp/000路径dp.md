# 路径类dp

路径类dp指在一个固定大小的矩阵中设置一个行走的规则，研究从起点到终点的方案数，或最小路径和、最大路径和等。

在之前介绍dp原理的数字三角形也是路径dp。

路径dp也是线性dp的一个分支。

## 矩阵的最小路径和

[矩阵的最小路径和_牛客题霸_牛客网](https://www.nowcoder.com/practice/38ae72379d42471db1c537914b06d48e?tpId=230&tqId=39755&ru=/exam/oj)

1. 状态表示

因为是路径dp，所以dp表一般是二维甚至多维。

这里的矩阵是二维，所以用`dp[i][j]`表示从起点走到`[i,j]`的最小路径和。

2. 转移方程

每一步都只有两个走法：走到`[i,j]`格子，只能从`[i-1,j]`或`[i,j-1]`走到。所以只要找到`[i-1,j]`或`[i,j-1]`的最小值，即可得到`[i,j]`的最小值。

所以方程：

`dp[i][j]=min(dp[i-1][j],dp[i][j-1])+a[i][j];`

3. 初始化

因为是找最小值，所以不能初始化为0，或初始化为0时要做特殊判断。

填`dp[1][1]`时，会用到`dp[1][0]`和`dp[0][1]`。`dp[0][j]`和`dp[i][0]`严格来说都是非法的格子。特别是`dp[1][j]`和`dp[i][1]`的格子会取到这些非法格子的状态，一旦`dp[0][j]`和`dp[i][0]`都初始化为0，`dp[1][j]`和`dp[i][1]`的格子很可能会取到0，而不是已经有的格子。

初始化为无穷大也不行，因为`dp[1][1]`会变成无穷大，进而影响后续的状态。

但说不初始化也不行，可以将`dp[0][1]`和`dp[1][0]`任选一个为0，其余的格子全部初始化为正无穷大（`0x3f3f3f3f`）。

4. 填表顺序

根据方程，只有上方格子先得到最优解，填下方格子时才能不出错。

还有一种填法，就是两个边界用额外的转移方程。比如这里：

`dp[1][j]=dp[1][j-1]+a[1][j]`和`dp[i][1]=dp[i-1][1]+a[i][1]`，因为这两个边界的转移方式只有一个。填完边界之后，再从`dp[2][2]`开始填，也能得到同样的效果。

参考程序1：可以将`dp[0][1]`和`dp[1][0]`任选一个为0。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n,m;
    cin>>n>>m;
    vector<vector<int> >dp(n+1,vector<int>(m+1,0x3f3f3f3f));
    dp[0][1]=0;
    for(int i=1,x;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>x;
            dp[i][j]=min(dp[i-1][j],dp[i][j-1])+x;
        }
    cout<<dp[n][m];
    return 0;
}
```

参考程序2：先处理边界，再处理剩下的格子。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n,m;
    cin>>n>>m;
    vector<vector<int> >dp(n+1,vector<int>(m+1,0));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>dp[i][j];
            if(i==1)
                dp[i][j]+=dp[i][j-1];
            if(j==1)
                dp[i][j]+=dp[i-1][j];
            if(i!=1&&j!=1)
                dp[i][j]+=min(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout<<dp[n][m];
    return 0;
}
```

## 迷雾森林 求方案数

[「木」迷雾森林](https://ac.nowcoder.com/acm/problem/53675)

1. 状态表示

用`num[i][j]`表示从起点`[m,1]`走到`[1,n]`的方法数。

2. 转移方程

每一步都只有两个走法：走到`[i,j]`格子，只能从`[i+1,j]`或`[i,j-1]`走到。所以只要将`[i-1,j]`或`[i,j-1]`的方法数叠加，即可得到走到`[i,j]`的方法数。

所以方程：

`num[i][j]=(num[i+1][j]+num[i][j-1])%2333;`，结果为`num[1][n]`。

也可以从终点走到起点。方程：

`num[i][j]=(num[i-1][j]+num[i][j+1])%2333;`结果为`num[m][1]`。

3. 初始化&&填表

因为是求方法数，做的也是加法，所以全部初始化为0也不会影响。但有一个点：如果起点也参与填表，则起点（或终点）的左边和下边（终点的右边和上边）二选1初始化为1，这样起点的方法数才能为1，后续的填表才能正常进行。

当然，也能和矩阵的最小路径和一样，先处理边界，再处理剩下的格子。

填表用两层循环，可以用外层`m~1`，内层`1~n`，结果是`num[1][n]`，也就是起点走到终点；也可以用外层`n~1`，内层`1~m`，结果是`num[m][1]`，也就是终点走到起点。这里从起点走到终点。

无论哪一个，填表时要注意那个格子能不能走。

参考程序1：正常处理，从起点走到终点。

```cpp
#include<iostream>
using namespace std;

template<class T>
inline void read(T& res) {
    char c;
    T flag = 1;
    while ((c = getchar()) < '0' || c > '9')
        if (c == '-')
            flag = -1;
    res = c - '0';
    while ((c = getchar()) >= '0' && c <= '9')
        res = res * 10 + c - '0';
    res *= flag;
}

int pct[3010][3010], num[3010][3010];
int n, m;

int main() {
    read(m);//可以用scanf，这里题目推荐了函数模板就用他的
    read(n);
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            read(pct[i][j]);
    
    num[m][0] = 1;//起点在左下角，求方法数见洛谷p1057传球游戏分析
    for(int i=m;i>=1;i--)
        for(int j=1;j<=n;j++)
            if(pct[i][j]==0)
                num[i][j]=(num[i+1][j]+num[i][j-1])%2333;
    
    cout << num[1][n];
    return 0;
}
```



参考程序2：先处理边界，`num[i][j]`表示从起点走到`[i,j]`的方法数。。

```cpp
#include<iostream>
using namespace std;

template<class T>
inline void read(T& res) {
    char c;
    T flag = 1;
    while ((c = getchar()) < '0' || c > '9')
        if (c == '-')
            flag = -1;
    res = c - '0';
    while ((c = getchar()) >= '0' && c <= '9')
        res = res * 10 + c - '0';
    res *= flag;
}

int pct[3010][3010], num[3010][3010];
int n, m;

int main() {
    read(m);
    read(n);
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            read(pct[i][j]);
    
    num[m][1] = 1;//起点在左下角，求方法数见洛谷p1057传球游戏分析
    for (int i = m - 1; i >= 1; i--) {//处理边界
        if (pct[i][1] == 0)
            num[i][1] = num[i + 1][1];
        else
            break;
    }
    for (int i = 2; i <= n; i++) {//处理边界
        if (pct[m][i] == 0)
            num[m][i] = num[m][i - 1];
        else
            break;
    }
    for (int i = m - 1; i >= 1; i--)
        for (int j = 2; j <= n; j++)
            if (pct[i][j] == 0)
                num[i][j] = (num[i + 1][j] + num[i][j - 1]) % 2333;
    
    cout << num[1][n];
    return 0;
}
```

因为转移方程是比较简单的数学表达式，有的书会把这种题归类为递推。

## NOIP2022 过河卒

[P1002 [NOIP 2002 普及组\] 过河卒 - 洛谷](https://www.luogu.com.cn/problem/P1002)

[1314：【例3.6】过河卒(Noip2002)](http://ybt.ssoier.cn:8088/problem_show.php?pid=1314)

分析方法和迷雾森林一样。这里只给出先处理边界的方案。

转移方程：

```cpp
zu[i][j]=zu[i-1][j]+zu[i][j-1]		//i>=0,j>=0,ma[i][j]=0
边界情况：
zu[i][j]=0		//ma[i][j]=1
zu[i][0]=zu[i-1][0]		//i > 0且ma[i][0] = 0
zu[0][j]=zu[0][j-1]		//j > 0且ma[0][j] = 0
zu[0][0]=1
```

还有一种情况就是卒和马的曼哈顿距离（平面上两点的横、纵坐标分别作差，后分别求和）为3的同时，横、纵坐标之一不和马相等，这种情况就是马点。

而且求的方法数因为也算是从不同的格子抵达，最后的数量是阶乘级别。所以用8字节的整数存储。

这里用的初始化边界。

```cpp
#include<iostream>
using namespace std;
typedef long long int ll;
int main() {
	ll zu[21][21] = { 0 };
	int zx = 0, zy = 0, mx = 0, my = 0,
		//马的方向数组
		vix[8] = { 1,1,-1,-1,2,2,-2,-2 },
		viy[8] = { -2,2,-2,2,1,-1,-1,1 };
	bool ma[21][21] = { 0 };

	cin >> zx >> zy >> mx >> my;
	ma[mx][my] = 1;

	for (int i = 0; i < 8; i++) {
		int ax = mx + vix[i], ay = my + viy[i];
		if (ax >= 0 && ax <= zx && ay >= 0 && ay <= zy)
			ma[ax][ay] = 1;
	}
	//边界条件1
	zu[0][0] = 1;
	//2
	for (int i = 1; i <= zx; i++) 
		if (ma[i][0] == 0)
			zu[i][0] = zu[i - 1][0];
		else
			zu[i][0] = 0;
	
	//3
	for (int j = 1; j <= zy; j++) 
		if (ma[0][j] == 0)
			zu[0][j] = zu[0][j - 1];
		else
			zu[0][j] = 0;
	
	for (int i = 1; i <= zx; i++) 
		for (int j = 1; j <= zy; j++) 
			if (ma[i][j] == 0) 
				zu[i][j] = zu[i - 1][j] + zu[i][j - 1];
			else
				zu[i][j] = 0;
	cout << zu[zx][zy];

	return 0;
}
```

## NOIP2000 方格取数

[P1004 [NOIP 2000 提高组\] 方格取数 - 洛谷](https://www.luogu.com.cn/problem/P1004)

[1823：【00NOIP提高组】方格取数](http://ybt.ssoier.cn:8088/problem_show.php?pid=1823)

路径dp，求最大的路径和。但是在一个时间轴上，两个人同时走，每个人都按照自己的方式去走。而且不能全部求和，因为可能做不到所有数据全覆盖。

### 尝试贪心

如果不按照dp的思路，尝试贪心，两人都找最大值。但有两个问题：

1. 每个路径只能走一次。

2. 存在反例。

例如：

```
1 2 1
0 0 0
1 66 0
```

按照贪心的策略，第一次走的时候就要取最大值，所以其中一个路径只能是$1\rightarrow2\rightarrow66\rightarrow0$，

所以第一次走完后，矩阵变成这个：

```
0 0 1
0 0 0
1 0 0
```

第二次走的时候依旧取最大值，此时有两种走法。但无论哪一种，都一定会剩下一个1，这个时候可以发现贪心居然有反例。

### 路径dp

贪心错的原因是最大路径和的策略会影响对最优情况的判断。所以，路径dp吸取贪心的教训，需要对两个人做同等的策略。

按照路径dp的方式分析：

1. 状态表示

这个题相当于两个人在走，起点是一样的，两人的速度是一样的，所以路程也一样，这时需要对某一时刻进行判断。

之前的路径因为只有1个人就需要二维数组表示，两个人就可以尝试四维状态。所以可以设`dp[i1][j1][i2][j2]`表示两人分别在`[i1,j1]`和`[i2,j2]`时的最大路径和。

四维的话需要判断条件：`i1+j1=i2+j2`，即两个人各种的横、纵坐标的改变量之和是相同的。如果用四维的话，会产生大量非法情况，但如果是这题的话也能过。

所以可以利用这个性质优化掉一维，即知三求一。所以四维的状态可以优化成三维：

设`dp[s][i1][i2]`表示横、纵坐标之和为`s`时，第1个人的横坐标（或纵坐标）为`i1`，第2个人的横坐标（或纵坐标）为`i2`时的最大路径和。求纵（横坐标）可以通过`s`减去已知坐标得到。

2. 转移方程

先看`dp[s][i1][i2]`：

按照最后一步划分，每个人有两种情况：从终点的视角看，可以走左边或走上边到达两人的位置，所以有4种情况：都向左，1向左、2向上，1向上、2向左，都向上（从人看平面的视角）。

若是都向左，即第1个人是从`[i1,s-1-i1]`走到`[i1,s-i1]`，同理第2个人是从`[i2,s-1-i2]`走到`[i2,s-i2]`，则`dp[s][i1][i2]=dp[s-1][i1][i2]`。

同理1向左、2向上的情况，`dp[s][i1][i2]=dp[s-1][i1][i2-1]`。

1向上、2向左的情况，`dp[s][i1][i2]=dp[s-1][i1-1][i2]`。

都向上，`dp[s][i1][i2]=dp[s-1][i1-1][i2-1]`。

4种情况取最大值即可得到最大的双路径和。

所以转移方程：

```cpp
dp[s][i1][j1]=max{
    dp[s-1][i1][i2],
    dp[s-1][i1][i2-1],
    dp[s-1][i1-1][i2],
	dp[s-1][i1-1][i2-1]
}+(i1==i2? a[i1][j1] + a[i2][j2] : a[i1][s-i1])
```

因为方程的参数比较多，适当的时候可以使用引用代替。

3. 初始化&填表顺序

这里的路径和全是大于0的，所以数组`dp`可以全为0。

三维状态需要三层循环。第1层横、纵坐标之和`s`从2到`2*n`，第2层横坐标`i1`从1枚举到`n`，第3层`i2`从1枚举到`n`。同时纵坐标还需要检查是否越界。

最终结果是`dp[2*n][n][n]`。

参考程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[11][11];
int dp[22][11][11];
int main() {
	cin >> n;
	int x, y, w;
	while (cin >> x >> y >> w, x)
		a[x][y] = w;
	for (int s = 2; s <= n + n; s++)
		for (int i1 = 1; i1 <= n; i1++)
			for (int i2 = 1; i2 <= n; i2++)
			{
				int j1 = s - i1, j2 = s - i2;
				if (j1 <= 0 || j1 > n || j2 <= 0 || j2 > n)
					continue;
				int t = dp[s - 1][i1][i2];
				t = max(t, dp[s - 1][i1][i2 - 1]);
				t = max(t, dp[s - 1][i1 - 1][i2]);
				t = max(t, dp[s - 1][i1 - 1][i2 - 1]);
				if (i1 == i2) 
					dp[s][i1][i2] = t + a[i1][j1]; 
				else 
					dp[s][i1][i2] = t + a[i1][j1] + a[i2][j2]; 
			}
	cout << dp[n + n][n][n] << endl;
	return 0;
}
```


# 混合背包问题

将01背包、完全背包、多重背包混合起来的背包问题。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。

## 01背包与完全背包的混合：

考虑到在01背包和完全背包的滚动数组优化只有内层循环不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是$O(V*N)$。

> 因为没找到题目，所以先写个思路在这里放着。

## 完全背包与多重背包的混合：

解决方法：

1. 两种背包问题都有相似的状态转移方程：

```cpp
dp[i][j]=max{
    dp[i-1][j],
    dp[i-1][j-w[i]]+v[i],
    dp[i-1][j-2*w[i]]+2*v[i],
    ...
    dp[i-1][j-k*w[i]]+k*v[i]
}
```

代码实现：

```cpp
for(int i=1;i<=N;i++)
    for(int j=0;j<=V;j++)
        for(int k=0;k<=s[i];k++)//当k=0时，dp[i][j]=dp[i-1][j]
            if(j>=k*w[i])
                dp[i][j]=max(dp[i][j],dp[i-1][j-k*w[i]]+k*v[i]);
```

所以完全背包可以转化为多重背包解决（多记录每种物品能放的数量）。

2. 它们也都有滚动数组优化，所以也能用滚动数组，只是需要判断选用哪个循环。

3. 二进制优化统一转化为01背包问题。

> 同样是没遇到类似的题，所以先写思路放着。

## 三种背包混合

[1270：【例9.14】混合背包](http://ybt.ssoier.cn:8088/problem_show.php?pid=1270)

[P1833 樱花 - 洛谷](https://www.luogu.com.cn/problem/P1833)

1. 分类讨论加流程优化。

因为三种背包都有一维的滚动数组优化方案，所以对每种物品分别处理。

[1270：【例9.14】混合背包](http://ybt.ssoier.cn:8088/problem_show.php?pid=1270)

```cpp
#define _CRT_SECURE_NO_WARNINGS 1

//将不同物品按背包分类进行求解：
#include <iostream>
using namespace std;
int m, n;
int dp[201];
int w, v, s;//流程优化

int main() {
	cin >> m >> n;
	for (int i = 1; i <= n; i++) {
		cin >> w >> v >> s;
		if (s == 1)//01背包
			for (int j = m; j >= w; j--)
				dp[j] = max(dp[j], dp[j - w] + v);
		else if (s == 0) {//完全背包
			for (int j = w; j <= m; j++)//状态压缩
				dp[j] = max(dp[j], dp[j - w] + v);
		}
		else {//多重背包
			for (int j = m; j >= w; j--)//状态压缩
				for (int k = 0; k <= s; k++)
					if (j >= k * w)
						dp[j] = max(dp[j], dp[j - k * w] + k * v);
		}
	}
	cout << dp[m];
	return 0;
}


```

2. 二进制优化。这里不再细述。

3. 单调队列优化。敬请期待。

[P1833 樱花 - 洛谷](https://www.luogu.com.cn/problem/P1833)

三种背包的混合，可以对每种样例分类讨论。

```cpp
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS 1
#endif

#include<bits/stdc++.h>
using namespace std;

int main() {
	int n;
	int h1, m1, h2, m;
	scanf("%d:%d", &h1, &m1);
	scanf("%d:%d", &h2, &m);
	m1 += h1 * 60;
	m += h2 * 60;
	m -= m1;
	cin >> n;
	int t, c, p;
	vector<int>dp(m + 1, 0);
	for (int i = 1; i <= n; i++) {
		cin >> t >> c >> p;
		if (p == 0)
			for (int j = t; j <= m; j++)
				dp[j] = max(dp[j], dp[j - t] + c);
		else
			for (int j = m; j >= t; j--)
				for (int k = 1; k <= p&&j>=k*t; k++)
					dp[j] = max(dp[j], dp[j - k * t] + k * c);
			
	}
	cout << dp[m];
	return 0;
}
```

## 混合背包OJ汇总

[1270：【例9.14】混合背包](http://ybt.ssoier.cn:8088/problem_show.php?pid=1270)

[P1833 樱花 - 洛谷](https://www.luogu.com.cn/problem/P1833)
